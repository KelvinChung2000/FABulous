Current pass: infer-data-path
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group stage1<"static"=4> {
      mult_pipe.left = a;
      mult_pipe.right = b;
      pipe1.in = mult_pipe.out;
      pipe1.write_en = mult_pipe.done;
      mult_pipe.go = !mult_pipe.done ? 1'd1;
      stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          stage1;
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: collapse-control
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group stage1<"static"=4> {
      mult_pipe.left = a;
      mult_pipe.right = b;
      pipe1.in = mult_pipe.out;
      pipe1.write_en = mult_pipe.done;
      mult_pipe.go = !mult_pipe.done ? 1'd1;
      stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          stage1;
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: compile-sync-without-sync-reg
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group stage1<"static"=4> {
      mult_pipe.left = a;
      mult_pipe.right = b;
      pipe1.in = mult_pipe.out;
      pipe1.write_en = mult_pipe.done;
      mult_pipe.go = !mult_pipe.done ? 1'd1;
      stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          stage1;
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: group2seq
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          seq {
            beg_spl_stage1;
            end_spl_stage1;
          }
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: dead-assign-removal
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          seq {
            beg_spl_stage1;
            end_spl_stage1;
          }
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: group2invoke
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      invoke data_valid_reg(
        in = data_valid
      )();
      par {
        if data_valid_reg.out {
          seq {
            invoke mult_pipe(
              left = a,
              right = b
            )();
            invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        if stage2_valid.out {
          invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      par {
        if data_valid_reg.out {
          invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          invoke stage2_valid(
            in = 1'd0
          )();
        }
        if stage2_valid.out {
          invoke out_valid(
            in = 1'd1
          )();
        } else {
          invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: inline
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      invoke data_valid_reg(
        in = data_valid
      )();
      par {
        if data_valid_reg.out {
          seq {
            invoke mult_pipe(
              left = a,
              right = b
            )();
            invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        if stage2_valid.out {
          invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      par {
        if data_valid_reg.out {
          invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          invoke stage2_valid(
            in = 1'd0
          )();
        }
        if stage2_valid.out {
          invoke out_valid(
            in = 1'd1
          )();
        } else {
          invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: comb-prop
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      invoke data_valid_reg(
        in = data_valid
      )();
      par {
        if data_valid_reg.out {
          seq {
            invoke mult_pipe(
              left = a,
              right = b
            )();
            invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        if stage2_valid.out {
          invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      par {
        if data_valid_reg.out {
          invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          invoke stage2_valid(
            in = 1'd0
          )();
        }
        if stage2_valid.out {
          invoke out_valid(
            in = 1'd1
          )();
        } else {
          invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: dead-cell-removal
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      invoke data_valid_reg(
        in = data_valid
      )();
      par {
        if data_valid_reg.out {
          seq {
            invoke mult_pipe(
              left = a,
              right = b
            )();
            invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        if stage2_valid.out {
          invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      par {
        if data_valid_reg.out {
          invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          invoke stage2_valid(
            in = 1'd0
          )();
        }
        if stage2_valid.out {
          invoke out_valid(
            in = 1'd1
          )();
        } else {
          invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: simplify-with-control
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond_wire = std_wire(32);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    static<1> group comb_invoke0 {
      add.left = pipe1.out;
      add.right = c;
      cond_wire.in = add.out;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      invoke data_valid_reg(
        in = data_valid
      )();
      par {
        if data_valid_reg.out {
          seq {
            invoke mult_pipe(
              left = a,
              right = b
            )();
            invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        if stage2_valid.out {
          invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      par {
        if data_valid_reg.out {
          invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          invoke stage2_valid(
            in = 1'd0
          )();
        }
        if stage2_valid.out {
          invoke out_valid(
            in = 1'd1
          )();
        } else {
          invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @generated cond_wire0 = std_wire(4);
  }
  wires {
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group comb_invoke0 {
      add0.left = 4'd1;
      add0.right = idx0.out;
      cond_wire0.in = add0.out;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      seq {
        in_range0;
        while cond_wire.out {
          seq {
            seq {
              par {
                store_a;
                store_b;
              }
              invoke mac(
                data_valid = 1'd1,
                a = read_a.out,
                b = read_b.out,
                c = mac.out
              )();
              invoke idx0(
                in = add0.out
              )() with comb_invoke;
            }
            in_range0;
          }
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: compile-invoke
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond_wire = std_wire(32);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    group invoke0 {
      data_valid_reg.write_en = 1'd1;
      invoke0[done] = data_valid_reg.done;
      data_valid_reg.in = data_valid;
    }
    group invoke1 {
      mult_pipe.go = 1'd1;
      invoke1[done] = mult_pipe.done;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    group invoke2 {
      pipe1.write_en = 1'd1;
      invoke2[done] = pipe1.done;
      pipe1.in = mult_pipe.out;
    }
    group invoke3 {
      pipe2.write_en = 1'd1;
      invoke3[done] = pipe2.done;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    group invoke4 {
      stage2_valid.write_en = 1'd1;
      invoke4[done] = stage2_valid.done;
      stage2_valid.in = 1'd1;
    }
    group invoke5 {
      stage2_valid.write_en = 1'd1;
      invoke5[done] = stage2_valid.done;
      stage2_valid.in = 1'd0;
    }
    group invoke6 {
      out_valid.write_en = 1'd1;
      invoke6[done] = out_valid.done;
      out_valid.in = 1'd1;
    }
    group invoke7 {
      out_valid.write_en = 1'd1;
      invoke7[done] = out_valid.done;
      out_valid.in = 1'd0;
    }
    static<1> group comb_invoke0 {
      add.left = pipe1.out;
      add.right = c;
      cond_wire.in = add.out;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      invoke0;
      par {
        if data_valid_reg.out {
          seq {
            invoke1;
            invoke2;
          }
        }
        if stage2_valid.out {
          invoke3;
        }
      }
      par {
        if data_valid_reg.out {
          invoke4;
        } else {
          invoke5;
        }
        if stage2_valid.out {
          invoke6;
        } else {
          invoke7;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @generated cond_wire0 = std_wire(4);
  }
  wires {
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1 {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3 {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group comb_invoke0 {
      add0.left = 4'd1;
      add0.right = idx0.out;
      cond_wire0.in = add0.out;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke0;
      invoke1;
      seq {
        in_range0;
        while cond_wire.out {
          seq {
            seq {
              par {
                store_a;
                store_b;
              }
              invoke2;
              invoke3;
            }
            in_range0;
          }
        }
      }
      invoke4;
      save_out;
    }
  }
}
Current pass: static-promotion
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond_wire = std_wire(32);
  }
  wires {
    group beg_spl_stage1<"promotable"=3> {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1<"promotable"=1> {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2<"promotable"=1> {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid<"promotable"=1> {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid<"promotable"=1> {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid<"promotable"=1> {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid<"promotable"=1> {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid<"promotable"=1> {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    group invoke0<"promotable"=1> {
      data_valid_reg.write_en = 1'd1;
      invoke0[done] = data_valid_reg.done;
      data_valid_reg.in = data_valid;
    }
    group invoke1<"promotable"=3> {
      mult_pipe.go = 1'd1;
      invoke1[done] = mult_pipe.done;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    group invoke2<"promotable"=1> {
      pipe1.write_en = 1'd1;
      invoke2[done] = pipe1.done;
      pipe1.in = mult_pipe.out;
    }
    group invoke3<"promotable"=1> {
      pipe2.write_en = 1'd1;
      invoke3[done] = pipe2.done;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    group invoke4<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke4[done] = stage2_valid.done;
      stage2_valid.in = 1'd1;
    }
    group invoke5<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke5[done] = stage2_valid.done;
      stage2_valid.in = 1'd0;
    }
    group invoke6<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke6[done] = out_valid.done;
      out_valid.in = 1'd1;
    }
    group invoke7<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke7[done] = out_valid.done;
      out_valid.in = 1'd0;
    }
    static<1> group comb_invoke0 {
      add.left = pipe1.out;
      add.right = c;
      cond_wire.in = add.out;
    }
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static<6> seq  {
      invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            invoke10;
            invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          invoke40;
        } else {
          invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          invoke60;
        } else {
          invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @generated cond_wire0 = std_wire(4);
  }
  wires {
    group store_a<"promotable"=1> {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b<"promotable"=1> {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx<"promotable"=1> {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group comb_invoke0 {
      add0.left = 4'd1;
      add0.right = idx0.out;
      cond_wire0.in = add0.out;
    }
    static<1> group store_a0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      static<1> par {
        store_a0;
        store_b0;
      }
      invoke0;
      invoke1;
      seq {
        in_range0;
        while cond_wire.out {
          seq {
            seq {
              static<1> par {
                store_a0;
                store_b0;
              }
              invoke2;
              invoke3;
            }
            in_range0;
          }
        }
      }
      invoke4;
      save_out;
    }
  }
}
Current pass: compile-repeat
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond_wire = std_wire(32);
  }
  wires {
    group beg_spl_stage1<"promotable"=3> {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1<"promotable"=1> {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2<"promotable"=1> {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid<"promotable"=1> {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid<"promotable"=1> {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid<"promotable"=1> {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid<"promotable"=1> {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid<"promotable"=1> {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    group invoke0<"promotable"=1> {
      data_valid_reg.write_en = 1'd1;
      invoke0[done] = data_valid_reg.done;
      data_valid_reg.in = data_valid;
    }
    group invoke1<"promotable"=3> {
      mult_pipe.go = 1'd1;
      invoke1[done] = mult_pipe.done;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    group invoke2<"promotable"=1> {
      pipe1.write_en = 1'd1;
      invoke2[done] = pipe1.done;
      pipe1.in = mult_pipe.out;
    }
    group invoke3<"promotable"=1> {
      pipe2.write_en = 1'd1;
      invoke3[done] = pipe2.done;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    group invoke4<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke4[done] = stage2_valid.done;
      stage2_valid.in = 1'd1;
    }
    group invoke5<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke5[done] = stage2_valid.done;
      stage2_valid.in = 1'd0;
    }
    group invoke6<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke6[done] = out_valid.done;
      out_valid.in = 1'd1;
    }
    group invoke7<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke7[done] = out_valid.done;
      out_valid.in = 1'd0;
    }
    static<1> group comb_invoke0 {
      add.left = pipe1.out;
      add.right = c;
      cond_wire.in = add.out;
    }
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static<6> seq  {
      invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            invoke10;
            invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          invoke40;
        } else {
          invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          invoke60;
        } else {
          invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @generated cond_wire0 = std_wire(4);
  }
  wires {
    group store_a<"promotable"=1> {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b<"promotable"=1> {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx<"promotable"=1> {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group comb_invoke0 {
      add0.left = 4'd1;
      add0.right = idx0.out;
      cond_wire0.in = add0.out;
    }
    static<1> group store_a0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      static<1> par {
        store_a0;
        store_b0;
      }
      invoke0;
      invoke1;
      seq {
        in_range0;
        while cond_wire.out {
          seq {
            seq {
              static<1> par {
                store_a0;
                store_b0;
              }
              invoke2;
              invoke3;
            }
            in_range0;
          }
        }
      }
      invoke4;
      save_out;
    }
  }
}
Current pass: dead-group-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond_wire = std_wire(32);
  }
  wires {
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static<6> seq  {
      invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            invoke10;
            invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          invoke40;
        } else {
          invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          invoke60;
        } else {
          invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @generated cond_wire0 = std_wire(4);
  }
  wires {
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group store_a0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
  }
  control {
    seq {
      static<1> par {
        store_a0;
        store_b0;
      }
      invoke0;
      invoke1;
      seq {
        in_range0;
        while cond_wire.out {
          seq {
            seq {
              static<1> par {
                store_a0;
                store_b0;
              }
              invoke2;
              invoke3;
            }
            in_range0;
          }
        }
      }
      invoke4;
      save_out;
    }
  }
}
Current pass: dead-cell-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static<6> seq  {
      invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            invoke10;
            invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          invoke40;
        } else {
          invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          invoke60;
        } else {
          invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
  }
  wires {
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group store_a0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
  }
  control {
    seq {
      static<1> par {
        store_a0;
        store_b0;
      }
      invoke0;
      invoke1;
      seq {
        in_range0;
        while cond_wire.out {
          seq {
            seq {
              static<1> par {
                store_a0;
                store_b0;
              }
              invoke2;
              invoke3;
            }
            in_range0;
          }
        }
      }
      invoke4;
      save_out;
    }
  }
}
Current pass: collapse-control
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static<6> seq  {
      invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            invoke10;
            invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          invoke40;
        } else {
          invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          invoke60;
        } else {
          invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
  }
  wires {
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group store_a0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
  }
  control {
    seq {
      static<1> par {
        store_a0;
        store_b0;
      }
      invoke0;
      invoke1;
      in_range0;
      while cond_wire.out {
        seq {
          static<1> par {
            store_a0;
            store_b0;
          }
          invoke2;
          invoke3;
          in_range0;
        }
      }
      invoke4;
      save_out;
    }
  }
}
Current pass: static-inline
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
  }
  wires {
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire0.in = %1 & %[1:5] ? data_valid_reg.out;
      cond.write_en = %1 & %[1:5] ? 1'd1;
      cond_wire0.in = %[2:5] & %[1:5] ? cond.out;
      mult_pipe.go = %[1:4] & %[1:5] & cond_wire0.out & %[1:5] ? 1'd1;
      mult_pipe.left = %[1:4] & %[1:5] & cond_wire0.out & %[1:5] ? a;
      mult_pipe.right = %[1:4] & %[1:5] & cond_wire0.out & %[1:5] ? b;
      pipe1.write_en = %4 & %[1:5] & cond_wire0.out & %[1:5] ? 1'd1;
      pipe1.in = %4 & %[1:5] & cond_wire0.out & %[1:5] ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 & %[1:5] ? 1'd1;
      pipe2.in = stage2_valid.out & %1 & %[1:5] ? add.out;
      add.left = stage2_valid.out & %1 & %[1:5] ? pipe1.out;
      add.right = stage2_valid.out & %1 & %[1:5] ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    static<4> group static_seq0<"promotable"=4> {
      mult_pipe.go = %[0:3] ? 1'd1;
      mult_pipe.left = %[0:3] ? a;
      mult_pipe.right = %[0:3] ? b;
      pipe1.write_en = %3 ? 1'd1;
      pipe1.in = %3 ? mult_pipe.out;
    }
    static<4> group static_if {
      cond.in = data_valid_reg.out;
      cond_wire0.in = %0 ? data_valid_reg.out;
      cond.write_en = %0 ? 1'd1;
      cond_wire0.in = %[1:4] ? cond.out;
      mult_pipe.go = %[0:3] & %[0:4] & cond_wire0.out ? 1'd1;
      mult_pipe.left = %[0:3] & %[0:4] & cond_wire0.out ? a;
      mult_pipe.right = %[0:3] & %[0:4] & cond_wire0.out ? b;
      pipe1.write_en = %3 & %[0:4] & cond_wire0.out ? 1'd1;
      pipe1.in = %3 & %[0:4] & cond_wire0.out ? mult_pipe.out;
    }
    static<1> group static_if0<"promotable"=1> {
      pipe2.write_en = stage2_valid.out ? 1'd1;
      pipe2.in = stage2_valid.out ? add.out;
      add.left = stage2_valid.out ? pipe1.out;
      add.right = stage2_valid.out ? c;
    }
    static<4> group static_par_thread<"promotable"=4> {
      cond.in = data_valid_reg.out;
      cond_wire0.in = %0 ? data_valid_reg.out;
      cond.write_en = %0 ? 1'd1;
      cond_wire0.in = %[1:4] ? cond.out;
      mult_pipe.go = %[0:3] & %[0:4] & cond_wire0.out ? 1'd1;
      mult_pipe.left = %[0:3] & %[0:4] & cond_wire0.out ? a;
      mult_pipe.right = %[0:3] & %[0:4] & cond_wire0.out ? b;
      pipe1.write_en = %3 & %[0:4] & cond_wire0.out ? 1'd1;
      pipe1.in = %3 & %[0:4] & cond_wire0.out ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %0 ? 1'd1;
      pipe2.in = stage2_valid.out & %0 ? add.out;
      add.left = stage2_valid.out & %0 ? pipe1.out;
      add.right = stage2_valid.out & %0 ? c;
    }
    static<1> group static_if1<"promotable"=1> {
      stage2_valid.write_en = data_valid_reg.out ? 1'd1;
      stage2_valid.in = data_valid_reg.out ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out ? 1'd1;
      stage2_valid.in = !data_valid_reg.out ? 1'd0;
    }
    static<1> group static_if2<"promotable"=1> {
      out_valid.write_en = stage2_valid.out ? 1'd1;
      out_valid.in = stage2_valid.out ? 1'd1;
      out_valid.write_en = !stage2_valid.out ? 1'd1;
      out_valid.in = !stage2_valid.out ? 1'd0;
    }
    static<1> group static_par_thread0<"promotable"=1> {
      stage2_valid.write_en = data_valid_reg.out ? 1'd1;
      stage2_valid.in = data_valid_reg.out ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out ? 1'd1;
      stage2_valid.in = !data_valid_reg.out ? 1'd0;
      out_valid.write_en = stage2_valid.out ? 1'd1;
      out_valid.in = stage2_valid.out ? 1'd1;
      out_valid.write_en = !stage2_valid.out ? 1'd1;
      out_valid.in = !stage2_valid.out ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
  }
  wires {
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group store_a0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group static_par_thread {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group static_par_thread0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
  }
  control {
    seq {
      static_par_thread;
      invoke0;
      invoke1;
      in_range0;
      while cond_wire.out {
        seq {
          static_par_thread0;
          invoke2;
          invoke3;
          in_range0;
        }
      }
      invoke4;
      save_out;
    }
  }
}
Current pass: dead-group-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire0.in = %1 & %[1:5] ? data_valid_reg.out;
      cond.write_en = %1 & %[1:5] ? 1'd1;
      cond_wire0.in = %[2:5] & %[1:5] ? cond.out;
      mult_pipe.go = %[1:4] & %[1:5] & cond_wire0.out & %[1:5] ? 1'd1;
      mult_pipe.left = %[1:4] & %[1:5] & cond_wire0.out & %[1:5] ? a;
      mult_pipe.right = %[1:4] & %[1:5] & cond_wire0.out & %[1:5] ? b;
      pipe1.write_en = %4 & %[1:5] & cond_wire0.out & %[1:5] ? 1'd1;
      pipe1.in = %4 & %[1:5] & cond_wire0.out & %[1:5] ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 & %[1:5] ? 1'd1;
      pipe2.in = stage2_valid.out & %1 & %[1:5] ? add.out;
      add.left = stage2_valid.out & %1 & %[1:5] ? pipe1.out;
      add.right = stage2_valid.out & %1 & %[1:5] ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
  }
  wires {
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group static_par_thread {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group static_par_thread0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
  }
  control {
    seq {
      static_par_thread;
      invoke0;
      invoke1;
      in_range0;
      while cond_wire.out {
        seq {
          static_par_thread0;
          invoke2;
          invoke3;
          in_range0;
        }
      }
      invoke4;
      save_out;
    }
  }
}
Current pass: dead-cell-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire0.in = %1 & %[1:5] ? data_valid_reg.out;
      cond.write_en = %1 & %[1:5] ? 1'd1;
      cond_wire0.in = %[2:5] & %[1:5] ? cond.out;
      mult_pipe.go = %[1:4] & %[1:5] & cond_wire0.out & %[1:5] ? 1'd1;
      mult_pipe.left = %[1:4] & %[1:5] & cond_wire0.out & %[1:5] ? a;
      mult_pipe.right = %[1:4] & %[1:5] & cond_wire0.out & %[1:5] ? b;
      pipe1.write_en = %4 & %[1:5] & cond_wire0.out & %[1:5] ? 1'd1;
      pipe1.in = %4 & %[1:5] & cond_wire0.out & %[1:5] ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 & %[1:5] ? 1'd1;
      pipe2.in = stage2_valid.out & %1 & %[1:5] ? add.out;
      add.left = stage2_valid.out & %1 & %[1:5] ? pipe1.out;
      add.right = stage2_valid.out & %1 & %[1:5] ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
  }
  wires {
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group static_par_thread {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group static_par_thread0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
  }
  control {
    seq {
      static_par_thread;
      invoke0;
      invoke1;
      in_range0;
      while cond_wire.out {
        seq {
          static_par_thread0;
          invoke2;
          invoke3;
          in_range0;
        }
      }
      invoke4;
      save_out;
    }
  }
}
Current pass: add-guard
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %[0:6] & %0 ? 1'd1;
      data_valid_reg.in = %[0:6] & %0 ? data_valid;
      cond.in = %[0:6] & %[1:5] ? data_valid_reg.out;
      cond_wire0.in = %[0:6] & %1 & %[1:5] ? data_valid_reg.out;
      cond.write_en = %[0:6] & %1 & %[1:5] ? 1'd1;
      cond_wire0.in = %[0:6] & %[2:5] & %[1:5] ? cond.out;
      mult_pipe.go = %[0:6] & %[1:4] & %[1:5] & cond_wire0.out & %[1:5] ? 1'd1;
      mult_pipe.left = %[0:6] & %[1:4] & %[1:5] & cond_wire0.out & %[1:5] ? a;
      mult_pipe.right = %[0:6] & %[1:4] & %[1:5] & cond_wire0.out & %[1:5] ? b;
      pipe1.write_en = %[0:6] & %4 & %[1:5] & cond_wire0.out & %[1:5] ? 1'd1;
      pipe1.in = %[0:6] & %4 & %[1:5] & cond_wire0.out & %[1:5] ? mult_pipe.out;
      pipe2.write_en = %[0:6] & stage2_valid.out & %1 & %[1:5] ? 1'd1;
      pipe2.in = %[0:6] & stage2_valid.out & %1 & %[1:5] ? add.out;
      add.left = %[0:6] & stage2_valid.out & %1 & %[1:5] ? pipe1.out;
      add.right = %[0:6] & stage2_valid.out & %1 & %[1:5] ? c;
      stage2_valid.write_en = %[0:6] & data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = %[0:6] & data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = %[0:6] & !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = %[0:6] & !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = %[0:6] & stage2_valid.out & %5 ? 1'd1;
      out_valid.in = %[0:6] & stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = %[0:6] & !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = %[0:6] & !stage2_valid.out & %5 ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
  }
  wires {
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group static_par_thread {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group static_par_thread0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
  }
  control {
    seq {
      static_par_thread;
      invoke0;
      invoke1;
      in_range0;
      while cond_wire.out {
        seq {
          static_par_thread0;
          invoke2;
          invoke3;
          in_range0;
        }
      }
      invoke4;
      save_out;
    }
  }
}
Current pass: simplify-static-guards
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire0.in = %1 ? data_valid_reg.out;
      cond.write_en = %1 ? 1'd1;
      cond_wire0.in = %[2:5] ? cond.out;
      mult_pipe.go = cond_wire0.out & %[1:4] ? 1'd1;
      mult_pipe.left = cond_wire0.out & %[1:4] ? a;
      mult_pipe.right = cond_wire0.out & %[1:4] ? b;
      pipe1.write_en = cond_wire0.out & %4 ? 1'd1;
      pipe1.in = cond_wire0.out & %4 ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 ? 1'd1;
      pipe2.in = stage2_valid.out & %1 ? add.out;
      add.left = stage2_valid.out & %1 ? pipe1.out;
      add.right = stage2_valid.out & %1 ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
  }
  wires {
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group static_par_thread {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group static_par_thread0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
  }
  control {
    seq {
      static_par_thread;
      invoke0;
      invoke1;
      in_range0;
      while cond_wire.out {
        seq {
          static_par_thread0;
          invoke2;
          invoke3;
          in_range0;
        }
      }
      invoke4;
      save_out;
    }
  }
}
Current pass: dead-group-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire0.in = %1 ? data_valid_reg.out;
      cond.write_en = %1 ? 1'd1;
      cond_wire0.in = %[2:5] ? cond.out;
      mult_pipe.go = cond_wire0.out & %[1:4] ? 1'd1;
      mult_pipe.left = cond_wire0.out & %[1:4] ? a;
      mult_pipe.right = cond_wire0.out & %[1:4] ? b;
      pipe1.write_en = cond_wire0.out & %4 ? 1'd1;
      pipe1.in = cond_wire0.out & %4 ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 ? 1'd1;
      pipe2.in = stage2_valid.out & %1 ? add.out;
      add.left = stage2_valid.out & %1 ? pipe1.out;
      add.right = stage2_valid.out & %1 ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
  }
  wires {
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group static_par_thread {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group static_par_thread0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
  }
  control {
    seq {
      static_par_thread;
      invoke0;
      invoke1;
      in_range0;
      while cond_wire.out {
        seq {
          static_par_thread0;
          invoke2;
          invoke3;
          in_range0;
        }
      }
      invoke4;
      save_out;
    }
  }
}
Current pass: assign-node-id
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire0.in = %1 ? data_valid_reg.out;
      cond.write_en = %1 ? 1'd1;
      cond_wire0.in = %[2:5] ? cond.out;
      mult_pipe.go = cond_wire0.out & %[1:4] ? 1'd1;
      mult_pipe.left = cond_wire0.out & %[1:4] ? a;
      mult_pipe.right = cond_wire0.out & %[1:4] ? b;
      pipe1.write_en = cond_wire0.out & %4 ? 1'd1;
      pipe1.in = cond_wire0.out & %4 ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 ? 1'd1;
      pipe2.in = stage2_valid.out & %1 ? add.out;
      add.left = stage2_valid.out & %1 ? pipe1.out;
      add.right = stage2_valid.out & %1 ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    @NODE_ID(0) static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
  }
  wires {
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group static_par_thread {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group static_par_thread0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
  }
  control {
    seq {
      @NODE_ID(0) static_par_thread;
      @NODE_ID invoke0;
      @NODE_ID(2) invoke1;
      @NODE_ID(3) in_range0;
      while cond_wire.out {
        seq {
          @NODE_ID(4) static_par_thread0;
          @NODE_ID(5) invoke2;
          @NODE_ID(6) invoke3;
          @NODE_ID(7) in_range0;
        }
      }
      @NODE_ID(8) invoke4;
      @NODE_ID(9) save_out;
    }
  }
}
Current pass: dfsm
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire0_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire0.in = %1 ? data_valid_reg.out;
      cond.write_en = %1 ? 1'd1;
      cond_wire0.in = %[2:5] ? cond.out;
      mult_pipe.go = cond_wire0.out & %[1:4] ? 1'd1;
      mult_pipe.left = cond_wire0.out & %[1:4] ? a;
      mult_pipe.right = cond_wire0.out & %[1:4] ? b;
      pipe1.write_en = cond_wire0.out & %4 ? 1'd1;
      pipe1.in = cond_wire0.out & %4 ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 ? 1'd1;
      pipe2.in = stage2_valid.out & %1 ? add.out;
      add.left = stage2_valid.out & %1 ? pipe1.out;
      add.right = stage2_valid.out & %1 ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire0.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire0.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    pipe1.write_en = cond_wire0.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire0.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
  }
  control {
    fsm;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    @data fsm_mac_a = std_wire(32);
    @data fsm_mac_b = std_wire(32);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @data fsm_cond_wire_in = std_wire(1);
    @data fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
  }
  wires {
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      cond_wire.in = lt0.out;
    }
    static<1> group static_par_thread {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group static_par_thread0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 2,
      2 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
      } => {
        mac.done -> 3,
        default -> 2,
      },
      3 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 4,
        default -> 3,
      },
      4 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 4,
      },
      5 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 6,
      6 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 7,
        default -> 6,
      },
      7 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 8,
        default -> 7,
      },
      8 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 8,
      },
      9 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 10,
        default -> 9,
      },
      10 : {
        fsm_out_addr0.in = !out.done ? 1'd0;
        fsm_out_write_en.in = !out.done ? 1'd1;
        fsm_out_write_data.in = !out.done ? mac.out;
      } => {
        out.done -> 11,
        default -> 10,
      },
      11 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    out.addr0 = !out.done ? fsm_out_addr0.out;
    out.write_en = !out.done ? fsm_out_write_en.out;
    out.write_data = !out.done ? fsm_out_write_data.out;
  }
  control {
    fsm;
  }
}
Current pass: dead-group-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire0_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire0.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire0.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    pipe1.write_en = cond_wire0.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire0.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
  }
  control {
    fsm;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    @data fsm_mac_a = std_wire(32);
    @data fsm_mac_b = std_wire(32);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @data fsm_cond_wire_in = std_wire(1);
    @data fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 2,
      2 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
      } => {
        mac.done -> 3,
        default -> 2,
      },
      3 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 4,
        default -> 3,
      },
      4 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 4,
      },
      5 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 6,
      6 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 7,
        default -> 6,
      },
      7 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 8,
        default -> 7,
      },
      8 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 8,
      },
      9 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 10,
        default -> 9,
      },
      10 : {
        fsm_out_addr0.in = !out.done ? 1'd0;
        fsm_out_write_en.in = !out.done ? 1'd1;
        fsm_out_write_data.in = !out.done ? mac.out;
      } => {
        out.done -> 11,
        default -> 10,
      },
      11 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    out.addr0 = !out.done ? fsm_out_addr0.out;
    out.write_en = !out.done ? fsm_out_write_en.out;
    out.write_data = !out.done ? fsm_out_write_data.out;
  }
  control {
    fsm;
  }
}
Current pass: wrap-main
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire0_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire0.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire0.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    pipe1.write_en = cond_wire0.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire0.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
  }
  control {
    fsm;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    @data fsm_mac_a = std_wire(32);
    @data fsm_mac_b = std_wire(32);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @data fsm_cond_wire_in = std_wire(1);
    @data fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 2,
      2 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
      } => {
        mac.done -> 3,
        default -> 2,
      },
      3 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 4,
        default -> 3,
      },
      4 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 4,
      },
      5 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 6,
      6 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 7,
        default -> 6,
      },
      7 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 8,
        default -> 7,
      },
      8 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 8,
      },
      9 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 10,
        default -> 9,
      },
      10 : {
        fsm_out_addr0.in = !out.done ? 1'd0;
        fsm_out_write_en.in = !out.done ? 1'd1;
        fsm_out_write_data.in = !out.done ? mac.out;
      } => {
        out.done -> 11,
        default -> 10,
      },
      11 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    out.addr0 = !out.done ? fsm_out_addr0.out;
    out.write_en = !out.done ? fsm_out_write_en.out;
    out.write_data = !out.done ? fsm_out_write_data.out;
  }
  control {
    fsm;
  }
}
Current pass: go-insertion
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire0_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire0.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire0.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    pipe1.write_en = cond_wire0.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire0.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
  }
  control {
    fsm;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    @data fsm_mac_a = std_wire(32);
    @data fsm_mac_b = std_wire(32);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @data fsm_cond_wire_in = std_wire(1);
    @data fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 2,
      2 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
      } => {
        mac.done -> 3,
        default -> 2,
      },
      3 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 4,
        default -> 3,
      },
      4 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 4,
      },
      5 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 6,
      6 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 7,
        default -> 6,
      },
      7 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 8,
        default -> 7,
      },
      8 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 8,
      },
      9 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 10,
        default -> 9,
      },
      10 : {
        fsm_out_addr0.in = !out.done ? 1'd0;
        fsm_out_write_en.in = !out.done ? 1'd1;
        fsm_out_write_data.in = !out.done ? mac.out;
      } => {
        out.done -> 11,
        default -> 10,
      },
      11 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    out.addr0 = !out.done ? fsm_out_addr0.out;
    out.write_en = !out.done ? fsm_out_write_en.out;
    out.write_data = !out.done ? fsm_out_write_data.out;
  }
  control {
    fsm;
  }
}
Current pass: wire-inliner
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire0_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire0.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire0.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    pipe1.write_en = cond_wire0.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire0.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
    fsm_start.in = go;
    done = fsm_done.out ? 1'd1;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    @data fsm_mac_a = std_wire(32);
    @data fsm_mac_b = std_wire(32);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @data fsm_cond_wire_in = std_wire(1);
    @data fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 2,
      2 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
      } => {
        mac.done -> 3,
        default -> 2,
      },
      3 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 4,
        default -> 3,
      },
      4 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 4,
      },
      5 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 6,
      6 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 7,
        default -> 6,
      },
      7 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 8,
        default -> 7,
      },
      8 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 8,
      },
      9 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 10,
        default -> 9,
      },
      10 : {
        fsm_out_addr0.in = !out.done ? 1'd0;
        fsm_out_write_en.in = !out.done ? 1'd1;
        fsm_out_write_data.in = !out.done ? mac.out;
      } => {
        out.done -> 11,
        default -> 10,
      },
      11 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    out.addr0 = !out.done ? fsm_out_addr0.out;
    out.write_en = !out.done ? fsm_out_write_en.out;
    out.write_data = !out.done ? fsm_out_write_data.out;
    fsm_start.in = go;
    done = fsm_done.out ? 1'd1;
  }
  control {}
}
Current pass: clk-insertion
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire0_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire0.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire0.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    pipe1.write_en = cond_wire0.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire0.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
    fsm_start.in = go;
    done = fsm_done.out ? 1'd1;
    mult_pipe.clk = clk;
    pipe1.clk = clk;
    pipe2.clk = clk;
    stage2_valid.clk = clk;
    out_valid.clk = clk;
    data_valid_reg.clk = clk;
    cond.clk = clk;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    @data fsm_mac_a = std_wire(32);
    @data fsm_mac_b = std_wire(32);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @data fsm_cond_wire_in = std_wire(1);
    @data fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 2,
      2 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
      } => {
        mac.done -> 3,
        default -> 2,
      },
      3 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 4,
        default -> 3,
      },
      4 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 4,
      },
      5 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 6,
      6 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 7,
        default -> 6,
      },
      7 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 8,
        default -> 7,
      },
      8 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 8,
      },
      9 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 10,
        default -> 9,
      },
      10 : {
        fsm_out_addr0.in = !out.done ? 1'd0;
        fsm_out_write_en.in = !out.done ? 1'd1;
        fsm_out_write_data.in = !out.done ? mac.out;
      } => {
        out.done -> 11,
        default -> 10,
      },
      11 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    out.addr0 = !out.done ? fsm_out_addr0.out;
    out.write_en = !out.done ? fsm_out_write_en.out;
    out.write_data = !out.done ? fsm_out_write_data.out;
    fsm_start.in = go;
    done = fsm_done.out ? 1'd1;
    a.clk = clk;
    b.clk = clk;
    out.clk = clk;
    read_a.clk = clk;
    read_b.clk = clk;
    idx0.clk = clk;
    mac.clk = clk;
  }
  control {}
}
Current pass: reset-insertion
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire0_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire0.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire0.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    pipe1.write_en = cond_wire0.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire0.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
    fsm_start.in = go;
    done = fsm_done.out ? 1'd1;
    mult_pipe.clk = clk;
    pipe1.clk = clk;
    pipe2.clk = clk;
    stage2_valid.clk = clk;
    out_valid.clk = clk;
    data_valid_reg.clk = clk;
    cond.clk = clk;
    mult_pipe.reset = reset;
    pipe1.reset = reset;
    pipe2.reset = reset;
    stage2_valid.reset = reset;
    out_valid.reset = reset;
    data_valid_reg.reset = reset;
    cond.reset = reset;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    @data fsm_mac_a = std_wire(32);
    @data fsm_mac_b = std_wire(32);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @data fsm_cond_wire_in = std_wire(1);
    @data fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 2,
      2 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
      } => {
        mac.done -> 3,
        default -> 2,
      },
      3 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 4,
        default -> 3,
      },
      4 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 4,
      },
      5 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 6,
      6 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 7,
        default -> 6,
      },
      7 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 8,
        default -> 7,
      },
      8 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 8,
      },
      9 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 10,
        default -> 9,
      },
      10 : {
        fsm_out_addr0.in = !out.done ? 1'd0;
        fsm_out_write_en.in = !out.done ? 1'd1;
        fsm_out_write_data.in = !out.done ? mac.out;
      } => {
        out.done -> 11,
        default -> 10,
      },
      11 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.c = !mac.done ? fsm_mac_c.out;
    out.addr0 = !out.done ? fsm_out_addr0.out;
    out.write_en = !out.done ? fsm_out_write_en.out;
    out.write_data = !out.done ? fsm_out_write_data.out;
    fsm_start.in = go;
    done = fsm_done.out ? 1'd1;
    a.clk = clk;
    b.clk = clk;
    out.clk = clk;
    read_a.clk = clk;
    read_b.clk = clk;
    idx0.clk = clk;
    mac.clk = clk;
    a.reset = reset;
    b.reset = reset;
    out.reset = reset;
    read_a.reset = reset;
    read_b.reset = reset;
    idx0.reset = reset;
    mac.reset = reset;
  }
  control {}
}
Current pass: merge-assigns
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire0_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire0.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire0.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    done = fsm_done.out ? 1'd1;
    out = pipe2.out;
    output_valid = out_valid.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    cond.write_en = fsm_cond_write_en.out;
    cond.clk = clk;
    cond.reset = reset;
    cond.in = fsm_cond_in.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.clk = clk;
    pipe2.reset = reset;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    out_valid.write_en = !stage2_valid.out | stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.clk = clk;
    out_valid.reset = reset;
    out_valid.in = !stage2_valid.out | stage2_valid.out ? fsm_out_valid_in.out;
    mult_pipe.clk = clk;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.reset = reset;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.clk = clk;
    data_valid_reg.reset = reset;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    stage2_valid.write_en = !data_valid_reg.out | data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.clk = clk;
    stage2_valid.reset = reset;
    stage2_valid.in = !data_valid_reg.out | data_valid_reg.out ? fsm_stage2_valid_in.out;
    pipe1.write_en = cond_wire0.out ? fsm_pipe1_write_en.out;
    pipe1.clk = clk;
    pipe1.reset = reset;
    pipe1.in = cond_wire0.out ? fsm_pipe1_in.out;
    fsm_start.in = go;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    @data fsm_mac_a = std_wire(32);
    @data fsm_mac_b = std_wire(32);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @data fsm_cond_wire_in = std_wire(1);
    @data fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 2,
      2 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
      } => {
        mac.done -> 3,
        default -> 2,
      },
      3 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 4,
        default -> 3,
      },
      4 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 4,
      },
      5 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 6,
      6 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 7,
        default -> 6,
      },
      7 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 8,
        default -> 7,
      },
      8 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 8,
      },
      9 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 10,
        default -> 9,
      },
      10 : {
        fsm_out_addr0.in = !out.done ? 1'd0;
        fsm_out_write_en.in = !out.done ? 1'd1;
        fsm_out_write_data.in = !out.done ? mac.out;
      } => {
        out.done -> 11,
        default -> 10,
      },
      11 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    done = fsm_done.out ? 1'd1;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    b.clk = clk;
    b.addr0 = fsm_b_addr0.out;
    b.reset = reset;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.clk = clk;
    read_b.reset = reset;
    read_b.in = fsm_read_b_in.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.clk = clk;
    idx0.reset = reset;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    a.clk = clk;
    a.addr0 = fsm_a_addr0.out;
    a.reset = reset;
    out.write_en = !out.done ? fsm_out_write_en.out;
    out.clk = clk;
    out.addr0 = !out.done ? fsm_out_addr0.out;
    out.reset = reset;
    out.write_data = !out.done ? fsm_out_write_data.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.clk = clk;
    read_a.reset = reset;
    read_a.in = fsm_read_a_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.clk = clk;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.reset = reset;
    mac.c = !mac.done ? fsm_mac_c.out;
    fsm_start.in = go;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
  }
  control {}
}
Current pass: default-assigns
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire0 = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire0_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire0.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire0.out ? a;
        fsm_mult_pipe_right.in = cond_wire0.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire0_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire0.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire0.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    done = fsm_done.out ? 1'd1;
    out = pipe2.out;
    output_valid = out_valid.out;
    cond_wire0.in = fsm_cond_wire0_in.out;
    cond.write_en = fsm_cond_write_en.out;
    cond.clk = clk;
    cond.reset = reset;
    cond.in = fsm_cond_in.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.clk = clk;
    pipe2.reset = reset;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    out_valid.write_en = !stage2_valid.out | stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.clk = clk;
    out_valid.reset = reset;
    out_valid.in = !stage2_valid.out | stage2_valid.out ? fsm_out_valid_in.out;
    mult_pipe.clk = clk;
    mult_pipe.left = cond_wire0.out ? fsm_mult_pipe_left.out;
    mult_pipe.go = cond_wire0.out ? fsm_mult_pipe_go.out;
    mult_pipe.reset = reset;
    mult_pipe.right = cond_wire0.out ? fsm_mult_pipe_right.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.clk = clk;
    data_valid_reg.reset = reset;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    stage2_valid.write_en = !data_valid_reg.out | data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.clk = clk;
    stage2_valid.reset = reset;
    stage2_valid.in = !data_valid_reg.out | data_valid_reg.out ? fsm_stage2_valid_in.out;
    pipe1.write_en = cond_wire0.out ? fsm_pipe1_write_en.out;
    pipe1.clk = clk;
    pipe1.reset = reset;
    pipe1.in = cond_wire0.out ? fsm_pipe1_in.out;
    fsm_start.in = go;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated cond_wire = std_wire(1);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    @data fsm_mac_a = std_wire(32);
    @data fsm_mac_b = std_wire(32);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @data fsm_cond_wire_in = std_wire(1);
    @data fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 2,
      2 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
      } => {
        mac.done -> 3,
        default -> 2,
      },
      3 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 4,
        default -> 3,
      },
      4 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 4,
      },
      5 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 6,
      6 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_data_valid.in = !mac.done ? 1'd1;
        fsm_mac_a.in = !mac.done ? read_a.out;
        fsm_mac_b.in = !mac.done ? read_b.out;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 7,
        default -> 6,
      },
      7 : {
        fsm_idx0_write_en.in = !idx0.done ? 1'd1;
        fsm_idx0_in.in = !idx0.done ? add0.out;
        fsm_add0_left.in = !idx0.done ? 4'd1;
        fsm_add0_right.in = !idx0.done ? idx0.out;
      } => {
        idx0.done -> 8,
        default -> 7,
      },
      8 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_cond_wire_in.in = lt0.out;
      } => {
        cond_wire.out -> 5,
        !cond_wire.out -> 9,
        default -> 8,
      },
      9 : {
        fsm_mac_go.in = !mac.done ? 1'd1;
        fsm_mac_c.in = !mac.done ? mac.out;
      } => {
        mac.done -> 10,
        default -> 9,
      },
      10 : {
        fsm_out_addr0.in = !out.done ? 1'd0;
        fsm_out_write_en.in = !out.done ? 1'd1;
        fsm_out_write_data.in = !out.done ? mac.out;
      } => {
        out.done -> 11,
        default -> 10,
      },
      11 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    done = fsm_done.out ? 1'd1;
    add0.left = !idx0.done ? fsm_add0_left.out;
    add0.right = !idx0.done ? fsm_add0_right.out;
    b.clk = clk;
    b.addr0 = fsm_b_addr0.out;
    b.reset = reset;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.clk = clk;
    read_b.reset = reset;
    read_b.in = fsm_read_b_in.out;
    idx0.write_en = !idx0.done ? fsm_idx0_write_en.out;
    idx0.clk = clk;
    idx0.reset = reset;
    idx0.in = !idx0.done ? fsm_idx0_in.out;
    a.clk = clk;
    a.addr0 = fsm_a_addr0.out;
    a.reset = reset;
    out.write_en = !out.done ? fsm_out_write_en.out;
    out.clk = clk;
    out.addr0 = !out.done ? fsm_out_addr0.out;
    out.reset = reset;
    out.write_data = !out.done ? fsm_out_write_data.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.clk = clk;
    read_a.reset = reset;
    read_a.in = fsm_read_a_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mac.b = !mac.done ? fsm_mac_b.out;
    mac.data_valid = !mac.done ? fsm_mac_data_valid.out;
    mac.clk = clk;
    mac.a = !mac.done ? fsm_mac_a.out;
    mac.go = !mac.done ? fsm_mac_go.out;
    mac.reset = reset;
    mac.c = !mac.done ? fsm_mac_c.out;
    fsm_start.in = go;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    a.write_en = 1'd0;
    b.write_en = 1'd0;
  }
  control {}
}
