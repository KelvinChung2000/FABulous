Current pass: infer-data-path
component pipelined_mac(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group stage1<"static"=4> {
      mult_pipe.left = a;
      mult_pipe.right = b;
      pipe1.in = mult_pipe.out;
      pipe1.write_en = mult_pipe.done;
      mult_pipe.go = !mult_pipe.done ? 1'd1;
      stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          stage1;
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group init_all {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
  }
  control {
    seq {
      init_all;
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: collapse-control
component pipelined_mac(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group stage1<"static"=4> {
      mult_pipe.left = a;
      mult_pipe.right = b;
      pipe1.in = mult_pipe.out;
      pipe1.write_en = mult_pipe.done;
      mult_pipe.go = !mult_pipe.done ? 1'd1;
      stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          stage1;
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group init_all {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
  }
  control {
    seq {
      init_all;
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: compile-sync-without-sync-reg
component pipelined_mac(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group stage1<"static"=4> {
      mult_pipe.left = a;
      mult_pipe.right = b;
      pipe1.in = mult_pipe.out;
      pipe1.write_en = mult_pipe.done;
      mult_pipe.go = !mult_pipe.done ? 1'd1;
      stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          stage1;
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group init_all {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
  }
  control {
    seq {
      init_all;
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: group2seq
component pipelined_mac(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          seq {
            beg_spl_stage1;
            end_spl_stage1;
          }
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group init_all {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
  }
  control {
    seq {
      init_all;
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: dead-assign-removal
component pipelined_mac(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          seq {
            beg_spl_stage1;
            end_spl_stage1;
          }
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group init_all {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
  }
  control {
    seq {
      init_all;
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: group2invoke
component pipelined_mac(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      invoke data_valid_reg(
        in = data_valid
      )();
      par {
        if data_valid_reg.out {
          seq {
            invoke mult_pipe(
              left = a,
              right = b
            )();
            invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        if stage2_valid.out {
          invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      par {
        if data_valid_reg.out {
          invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          invoke stage2_valid(
            in = 1'd0
          )();
        }
        if stage2_valid.out {
          invoke out_valid(
            in = 1'd1
          )();
        } else {
          invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group init_all {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      invoke idx0(
        in = 4'd0
      )();
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: inline
component pipelined_mac(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      invoke data_valid_reg(
        in = data_valid
      )();
      par {
        if data_valid_reg.out {
          seq {
            invoke mult_pipe(
              left = a,
              right = b
            )();
            invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        if stage2_valid.out {
          invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      par {
        if data_valid_reg.out {
          invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          invoke stage2_valid(
            in = 1'd0
          )();
        }
        if stage2_valid.out {
          invoke out_valid(
            in = 1'd1
          )();
        } else {
          invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group init_all {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      invoke idx0(
        in = 4'd0
      )();
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: comb-prop
component pipelined_mac(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      invoke data_valid_reg(
        in = data_valid
      )();
      par {
        if data_valid_reg.out {
          seq {
            invoke mult_pipe(
              left = a,
              right = b
            )();
            invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        if stage2_valid.out {
          invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      par {
        if data_valid_reg.out {
          invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          invoke stage2_valid(
            in = 1'd0
          )();
        }
        if stage2_valid.out {
          invoke out_valid(
            in = 1'd1
          )();
        } else {
          invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group init_all {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      invoke idx0(
        in = 4'd0
      )();
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: dead-cell-removal
component pipelined_mac(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      invoke data_valid_reg(
        in = data_valid
      )();
      par {
        if data_valid_reg.out {
          seq {
            invoke mult_pipe(
              left = a,
              right = b
            )();
            invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        if stage2_valid.out {
          invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      par {
        if data_valid_reg.out {
          invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          invoke stage2_valid(
            in = 1'd0
          )();
        }
        if stage2_valid.out {
          invoke out_valid(
            in = 1'd1
          )();
        } else {
          invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group init_all {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      invoke idx0(
        in = 4'd0
      )();
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: simplify-with-control
component pipelined_mac(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    static<1> group comb_invoke0 {
      add.left = pipe1.out;
      add.right = c;
      comb_reg.in = add.out;
      comb_reg.write_en = 1'd1;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      invoke data_valid_reg(
        in = data_valid
      )();
      par {
        if data_valid_reg.out {
          seq {
            invoke mult_pipe(
              left = a,
              right = b
            )();
            invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        if stage2_valid.out {
          invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      par {
        if data_valid_reg.out {
          invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          invoke stage2_valid(
            in = 1'd0
          )();
        }
        if stage2_valid.out {
          invoke out_valid(
            in = 1'd1
          )();
        } else {
          invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    group init_all {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group comb_invoke0 {
      add0.left = 4'd1;
      add0.right = idx0.out;
      comb_reg0.in = add0.out;
      comb_reg0.write_en = 1'd1;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      invoke idx0(
        in = 4'd0
      )();
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      seq {
        in_range0;
        while comb_reg.out {
          seq {
            seq {
              par {
                store_a;
                store_b;
              }
              invoke mac(
                data_valid = 1'd1,
                a = read_a.out,
                b = read_b.out,
                c = mac.out
              )();
              invoke idx0(
                in = add0.out
              )() with comb_invoke;
            }
            in_range0;
          }
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: compile-invoke
component pipelined_mac(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    group invoke0 {
      data_valid_reg.write_en = 1'd1;
      invoke0[done] = data_valid_reg.done;
      data_valid_reg.in = data_valid;
    }
    group invoke1 {
      mult_pipe.go = 1'd1;
      invoke1[done] = mult_pipe.done;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    group invoke2 {
      pipe1.write_en = 1'd1;
      invoke2[done] = pipe1.done;
      pipe1.in = mult_pipe.out;
    }
    group invoke3 {
      pipe2.write_en = 1'd1;
      invoke3[done] = pipe2.done;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    group invoke4 {
      stage2_valid.write_en = 1'd1;
      invoke4[done] = stage2_valid.done;
      stage2_valid.in = 1'd1;
    }
    group invoke5 {
      stage2_valid.write_en = 1'd1;
      invoke5[done] = stage2_valid.done;
      stage2_valid.in = 1'd0;
    }
    group invoke6 {
      out_valid.write_en = 1'd1;
      invoke6[done] = out_valid.done;
      out_valid.in = 1'd1;
    }
    group invoke7 {
      out_valid.write_en = 1'd1;
      invoke7[done] = out_valid.done;
      out_valid.in = 1'd0;
    }
    static<1> group comb_invoke0 {
      add.left = pipe1.out;
      add.right = c;
      comb_reg.in = add.out;
      comb_reg.write_en = 1'd1;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      invoke0;
      par {
        if data_valid_reg.out {
          seq {
            invoke1;
            invoke2;
          }
        }
        if stage2_valid.out {
          invoke3;
        }
      }
      par {
        if data_valid_reg.out {
          invoke4;
        } else {
          invoke5;
        }
        if stage2_valid.out {
          invoke6;
        } else {
          invoke7;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    group init_all {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0 {
      idx0.write_en = 1'd1;
      invoke0[done] = idx0.done;
      idx0.in = 4'd0;
    }
    group invoke1 {
      mac.go = 1'd1;
      invoke1[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke2 {
      idx0.write_en = 1'd1;
      invoke2[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke3 {
      mac.go = 1'd1;
      invoke3[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke4 {
      idx0.write_en = 1'd1;
      invoke4[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke5 {
      mac.go = 1'd1;
      invoke5[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group comb_invoke0 {
      add0.left = 4'd1;
      add0.right = idx0.out;
      comb_reg0.in = add0.out;
      comb_reg0.write_en = 1'd1;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      invoke0;
      par {
        store_a;
        store_b;
      }
      invoke1;
      invoke2;
      seq {
        in_range0;
        while comb_reg.out {
          seq {
            seq {
              par {
                store_a;
                store_b;
              }
              invoke3;
              invoke4;
            }
            in_range0;
          }
        }
      }
      invoke5;
      save_out;
    }
  }
}
Current pass: static-inference
component pipelined_mac(data_valid: 1, a: 32, b: 32, c: 32, @go @promotable(6) go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
  }
  wires {
    group beg_spl_stage1<"promotable"=3> {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1<"promotable"=1> {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2<"promotable"=1> {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid<"promotable"=1> {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid<"promotable"=1> {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid<"promotable"=1> {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid<"promotable"=1> {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid<"promotable"=1> {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    group invoke0<"promotable"=1> {
      data_valid_reg.write_en = 1'd1;
      invoke0[done] = data_valid_reg.done;
      data_valid_reg.in = data_valid;
    }
    group invoke1<"promotable"=3> {
      mult_pipe.go = 1'd1;
      invoke1[done] = mult_pipe.done;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    group invoke2<"promotable"=1> {
      pipe1.write_en = 1'd1;
      invoke2[done] = pipe1.done;
      pipe1.in = mult_pipe.out;
    }
    group invoke3<"promotable"=1> {
      pipe2.write_en = 1'd1;
      invoke3[done] = pipe2.done;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    group invoke4<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke4[done] = stage2_valid.done;
      stage2_valid.in = 1'd1;
    }
    group invoke5<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke5[done] = stage2_valid.done;
      stage2_valid.in = 1'd0;
    }
    group invoke6<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke6[done] = out_valid.done;
      out_valid.in = 1'd1;
    }
    group invoke7<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke7[done] = out_valid.done;
      out_valid.in = 1'd0;
    }
    static<1> group comb_invoke0 {
      add.left = pipe1.out;
      add.right = c;
      comb_reg.in = add.out;
      comb_reg.write_en = 1'd1;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    @promotable(6) seq {
      @promotable invoke0;
      @promotable(4) par {
        @promotable(4) if data_valid_reg.out {
          @promotable(4) seq {
            @promotable(3) invoke1;
            @promotable invoke2;
          }
        }
        @promotable if stage2_valid.out {
          @promotable invoke3;
        }
      }
      @promotable par {
        @promotable if data_valid_reg.out {
          @promotable invoke4;
        } else {
          @promotable invoke5;
        }
        @promotable if stage2_valid.out {
          @promotable invoke6;
        } else {
          @promotable invoke7;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    group init_all<"promotable"=1> {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a<"promotable"=1> {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b<"promotable"=1> {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx<"promotable"=1> {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke0[done] = idx0.done;
      idx0.in = 4'd0;
    }
    group invoke1<"promotable"=6> {
      mac.go = 1'd1;
      invoke1[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke2<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke2[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke3<"promotable"=6> {
      mac.go = 1'd1;
      invoke3[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke4<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke4[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke5<"promotable"=6> {
      mac.go = 1'd1;
      invoke5[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group comb_invoke0 {
      add0.left = 4'd1;
      add0.right = idx0.out;
      comb_reg0.in = add0.out;
      comb_reg0.write_en = 1'd1;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      @promotable invoke0;
      @promotable par {
        @promotable store_a;
        @promotable store_b;
      }
      @promotable(6) invoke1;
      @promotable invoke2;
      seq {
        @promotable in_range0;
        while comb_reg.out {
          @promotable(9) seq {
            @promotable(8) seq {
              @promotable par {
                @promotable store_a;
                @promotable store_b;
              }
              @promotable(6) invoke3;
              @promotable invoke4;
            }
            @promotable in_range0;
          }
        }
      }
      @promotable(6) invoke5;
      @promotable save_out;
    }
  }
}
Current pass: static-promotion
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
  }
  wires {
    group beg_spl_stage1<"promotable"=3> {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1<"promotable"=1> {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2<"promotable"=1> {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid<"promotable"=1> {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid<"promotable"=1> {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid<"promotable"=1> {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid<"promotable"=1> {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid<"promotable"=1> {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    group invoke0<"promotable"=1> {
      data_valid_reg.write_en = 1'd1;
      invoke0[done] = data_valid_reg.done;
      data_valid_reg.in = data_valid;
    }
    group invoke1<"promotable"=3> {
      mult_pipe.go = 1'd1;
      invoke1[done] = mult_pipe.done;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    group invoke2<"promotable"=1> {
      pipe1.write_en = 1'd1;
      invoke2[done] = pipe1.done;
      pipe1.in = mult_pipe.out;
    }
    group invoke3<"promotable"=1> {
      pipe2.write_en = 1'd1;
      invoke3[done] = pipe2.done;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    group invoke4<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke4[done] = stage2_valid.done;
      stage2_valid.in = 1'd1;
    }
    group invoke5<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke5[done] = stage2_valid.done;
      stage2_valid.in = 1'd0;
    }
    group invoke6<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke6[done] = out_valid.done;
      out_valid.in = 1'd1;
    }
    group invoke7<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke7[done] = out_valid.done;
      out_valid.in = 1'd0;
    }
    static<1> group comb_invoke0 {
      add.left = pipe1.out;
      add.right = c;
      comb_reg.in = add.out;
      comb_reg.write_en = 1'd1;
    }
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static<6> seq  {
      invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            invoke10;
            invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          invoke40;
        } else {
          invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          invoke60;
        } else {
          invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    group init_all<"promotable"=1> {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a<"promotable"=1> {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b<"promotable"=1> {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx<"promotable"=1> {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke0[done] = idx0.done;
      idx0.in = 4'd0;
    }
    group invoke1<"promotable"=6> {
      mac.go = 1'd1;
      invoke1[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke2<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke2[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke3<"promotable"=6> {
      mac.go = 1'd1;
      invoke3[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke4<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke4[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke5<"promotable"=6> {
      mac.go = 1'd1;
      invoke5[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group comb_invoke0 {
      add0.left = 4'd1;
      add0.right = idx0.out;
      comb_reg0.in = add0.out;
      comb_reg0.write_en = 1'd1;
    }
    static<1> group store_a0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group no-op {
    }
    static<6> group invoke30 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    static<1> group invoke40 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    static<2> group no-op0 {
    }
    static<1> group invoke00 {
      idx0.write_en = 1'd1;
      idx0.in = 4'd0;
    }
    static<6> group invoke10 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    static<1> group invoke20 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    static<6> group invoke50 {
      mac.go = 1'd1;
      mac.c = mac.out;
    }
    static<1> group save_out0 {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      @promoted static<8> par {
        static<8> seq  {
          invoke00;
          @promotable static<1> par {
            store_a0;
            store_b0;
          }
          invoke10;
        }
        static<3> seq  {
          no-op0;
          invoke20;
        }
      }
      seq {
        in_range0;
        while comb_reg.out {
          static<8> seq  {
            @promotable(7) @promoted static<7> par {
              static<7> seq  {
                @promotable static<1> par {
                  store_a0;
                  store_b0;
                }
                invoke30;
              }
              static<2> seq  {
                no-op;
                invoke40;
              }
            }
            @promotable in_range0;
          }
        }
      }
      static<7> seq  {
        invoke50;
        save_out0;
      }
    }
  }
}
Current pass: compile-repeat
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
  }
  wires {
    group beg_spl_stage1<"promotable"=3> {
      mult_pipe.left = a;
      mult_pipe.right = b;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1<"promotable"=1> {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2<"promotable"=1> {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid<"promotable"=1> {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid<"promotable"=1> {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid<"promotable"=1> {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid<"promotable"=1> {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid<"promotable"=1> {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    group invoke0<"promotable"=1> {
      data_valid_reg.write_en = 1'd1;
      invoke0[done] = data_valid_reg.done;
      data_valid_reg.in = data_valid;
    }
    group invoke1<"promotable"=3> {
      mult_pipe.go = 1'd1;
      invoke1[done] = mult_pipe.done;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    group invoke2<"promotable"=1> {
      pipe1.write_en = 1'd1;
      invoke2[done] = pipe1.done;
      pipe1.in = mult_pipe.out;
    }
    group invoke3<"promotable"=1> {
      pipe2.write_en = 1'd1;
      invoke3[done] = pipe2.done;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    group invoke4<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke4[done] = stage2_valid.done;
      stage2_valid.in = 1'd1;
    }
    group invoke5<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke5[done] = stage2_valid.done;
      stage2_valid.in = 1'd0;
    }
    group invoke6<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke6[done] = out_valid.done;
      out_valid.in = 1'd1;
    }
    group invoke7<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke7[done] = out_valid.done;
      out_valid.in = 1'd0;
    }
    static<1> group comb_invoke0 {
      add.left = pipe1.out;
      add.right = c;
      comb_reg.in = add.out;
      comb_reg.write_en = 1'd1;
    }
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    comb group comb_invoke {
      add.left = pipe1.out;
      add.right = c;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static<6> seq  {
      invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            invoke10;
            invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          invoke40;
        } else {
          invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          invoke60;
        } else {
          invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    group init_all<"promotable"=1> {
      idx0.in = 4'd0;
      idx0.write_en = 1'd1;
      init_all[done] = idx0.done;
    }
    group store_a<"promotable"=1> {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b<"promotable"=1> {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx<"promotable"=1> {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out<"promotable"=1> {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    group invoke0<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke0[done] = idx0.done;
      idx0.in = 4'd0;
    }
    group invoke1<"promotable"=6> {
      mac.go = 1'd1;
      invoke1[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke2<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke2[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke3<"promotable"=6> {
      mac.go = 1'd1;
      invoke3[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke4<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke4[done] = idx0.done;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    group invoke5<"promotable"=6> {
      mac.go = 1'd1;
      invoke5[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group comb_invoke0 {
      add0.left = 4'd1;
      add0.right = idx0.out;
      comb_reg0.in = add0.out;
      comb_reg0.write_en = 1'd1;
    }
    static<1> group store_a0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group no-op {
    }
    static<6> group invoke30 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    static<1> group invoke40 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    static<2> group no-op0 {
    }
    static<1> group invoke00 {
      idx0.write_en = 1'd1;
      idx0.in = 4'd0;
    }
    static<6> group invoke10 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    static<1> group invoke20 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    static<6> group invoke50 {
      mac.go = 1'd1;
      mac.c = mac.out;
    }
    static<1> group save_out0 {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    comb group comb_invoke {
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
  }
  control {
    seq {
      @promoted static<8> par {
        static<8> seq  {
          invoke00;
          @promotable static<1> par {
            store_a0;
            store_b0;
          }
          invoke10;
        }
        static<3> seq  {
          no-op0;
          invoke20;
        }
      }
      seq {
        in_range0;
        while comb_reg.out {
          static<8> seq  {
            @promotable(7) @promoted static<7> par {
              static<7> seq  {
                @promotable static<1> par {
                  store_a0;
                  store_b0;
                }
                invoke30;
              }
              static<2> seq  {
                no-op;
                invoke40;
              }
            }
            @promotable in_range0;
          }
        }
      }
      static<7> seq  {
        invoke50;
        save_out0;
      }
    }
  }
}
Current pass: dead-group-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
  }
  wires {
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static<6> seq  {
      invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            invoke10;
            invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          invoke40;
        } else {
          invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          invoke60;
        } else {
          invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group store_a0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group no-op {
    }
    static<6> group invoke30 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    static<1> group invoke40 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    static<2> group no-op0 {
    }
    static<1> group invoke00 {
      idx0.write_en = 1'd1;
      idx0.in = 4'd0;
    }
    static<6> group invoke10 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    static<1> group invoke20 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    static<6> group invoke50 {
      mac.go = 1'd1;
      mac.c = mac.out;
    }
    static<1> group save_out0 {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
    }
  }
  control {
    seq {
      @promoted static<8> par {
        static<8> seq  {
          invoke00;
          @promotable static<1> par {
            store_a0;
            store_b0;
          }
          invoke10;
        }
        static<3> seq  {
          no-op0;
          invoke20;
        }
      }
      seq {
        in_range0;
        while comb_reg.out {
          static<8> seq  {
            @promotable(7) @promoted static<7> par {
              static<7> seq  {
                @promotable static<1> par {
                  store_a0;
                  store_b0;
                }
                invoke30;
              }
              static<2> seq  {
                no-op;
                invoke40;
              }
            }
            @promotable in_range0;
          }
        }
      }
      static<7> seq  {
        invoke50;
        save_out0;
      }
    }
  }
}
Current pass: dead-cell-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static<6> seq  {
      invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            invoke10;
            invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          invoke40;
        } else {
          invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          invoke60;
        } else {
          invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
  }
  wires {
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group store_a0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group no-op {
    }
    static<6> group invoke30 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    static<1> group invoke40 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    static<2> group no-op0 {
    }
    static<1> group invoke00 {
      idx0.write_en = 1'd1;
      idx0.in = 4'd0;
    }
    static<6> group invoke10 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    static<1> group invoke20 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    static<6> group invoke50 {
      mac.go = 1'd1;
      mac.c = mac.out;
    }
    static<1> group save_out0 {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
    }
  }
  control {
    seq {
      @promoted static<8> par {
        static<8> seq  {
          invoke00;
          @promotable static<1> par {
            store_a0;
            store_b0;
          }
          invoke10;
        }
        static<3> seq  {
          no-op0;
          invoke20;
        }
      }
      seq {
        in_range0;
        while comb_reg.out {
          static<8> seq  {
            @promotable(7) @promoted static<7> par {
              static<7> seq  {
                @promotable static<1> par {
                  store_a0;
                  store_b0;
                }
                invoke30;
              }
              static<2> seq  {
                no-op;
                invoke40;
              }
            }
            @promotable in_range0;
          }
        }
      }
      static<7> seq  {
        invoke50;
        save_out0;
      }
    }
  }
}
Current pass: collapse-control
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static<6> seq  {
      invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            invoke10;
            invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          invoke40;
        } else {
          invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          invoke60;
        } else {
          invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
  }
  wires {
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group store_a0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group no-op {
    }
    static<6> group invoke30 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    static<1> group invoke40 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    static<2> group no-op0 {
    }
    static<1> group invoke00 {
      idx0.write_en = 1'd1;
      idx0.in = 4'd0;
    }
    static<6> group invoke10 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    static<1> group invoke20 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    static<6> group invoke50 {
      mac.go = 1'd1;
      mac.c = mac.out;
    }
    static<1> group save_out0 {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
    }
  }
  control {
    seq {
      @promoted static<8> par {
        static<8> seq  {
          invoke00;
          @promotable static<1> par {
            store_a0;
            store_b0;
          }
          invoke10;
        }
        static<3> seq  {
          no-op0;
          invoke20;
        }
      }
      in_range0;
      while comb_reg.out {
        static<8> seq  {
          @promotable(7) @promoted static<7> par {
            static<7> seq  {
              @promotable static<1> par {
                store_a0;
                store_b0;
              }
              invoke30;
            }
            static<2> seq  {
              no-op;
              invoke40;
            }
          }
          @promotable in_range0;
        }
      }
      static<7> seq  {
        invoke50;
        save_out0;
      }
    }
  }
}
Current pass: static-inline
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
  }
  wires {
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.left = a;
      mult_pipe.right = b;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire.in = %1 & %[1:5] ? data_valid_reg.out;
      cond.write_en = %1 & %[1:5] ? 1'd1;
      cond_wire.in = %[2:5] & %[1:5] ? cond.out;
      mult_pipe.go = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      mult_pipe.left = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? a;
      mult_pipe.right = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? b;
      pipe1.write_en = %4 & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      pipe1.in = %4 & %[1:5] & cond_wire.out & %[1:5] ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 & %[1:5] ? 1'd1;
      pipe2.in = stage2_valid.out & %1 & %[1:5] ? add.out;
      add.left = stage2_valid.out & %1 & %[1:5] ? pipe1.out;
      add.right = stage2_valid.out & %1 & %[1:5] ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    static<4> group static_seq0<"promotable"=4> {
      mult_pipe.go = %[0:3] ? 1'd1;
      mult_pipe.left = %[0:3] ? a;
      mult_pipe.right = %[0:3] ? b;
      pipe1.write_en = %3 ? 1'd1;
      pipe1.in = %3 ? mult_pipe.out;
    }
    static<4> group static_if {
      cond.in = data_valid_reg.out;
      cond_wire.in = %0 ? data_valid_reg.out;
      cond.write_en = %0 ? 1'd1;
      cond_wire.in = %[1:4] ? cond.out;
      mult_pipe.go = %[0:3] & %[0:4] & cond_wire.out ? 1'd1;
      mult_pipe.left = %[0:3] & %[0:4] & cond_wire.out ? a;
      mult_pipe.right = %[0:3] & %[0:4] & cond_wire.out ? b;
      pipe1.write_en = %3 & %[0:4] & cond_wire.out ? 1'd1;
      pipe1.in = %3 & %[0:4] & cond_wire.out ? mult_pipe.out;
    }
    static<1> group static_if0<"promotable"=1> {
      pipe2.write_en = stage2_valid.out ? 1'd1;
      pipe2.in = stage2_valid.out ? add.out;
      add.left = stage2_valid.out ? pipe1.out;
      add.right = stage2_valid.out ? c;
    }
    static<4> group static_par_thread<"promotable"=4> {
      cond.in = data_valid_reg.out;
      cond_wire.in = %0 ? data_valid_reg.out;
      cond.write_en = %0 ? 1'd1;
      cond_wire.in = %[1:4] ? cond.out;
      mult_pipe.go = %[0:3] & %[0:4] & cond_wire.out ? 1'd1;
      mult_pipe.left = %[0:3] & %[0:4] & cond_wire.out ? a;
      mult_pipe.right = %[0:3] & %[0:4] & cond_wire.out ? b;
      pipe1.write_en = %3 & %[0:4] & cond_wire.out ? 1'd1;
      pipe1.in = %3 & %[0:4] & cond_wire.out ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %0 ? 1'd1;
      pipe2.in = stage2_valid.out & %0 ? add.out;
      add.left = stage2_valid.out & %0 ? pipe1.out;
      add.right = stage2_valid.out & %0 ? c;
    }
    static<1> group static_if1<"promotable"=1> {
      stage2_valid.write_en = data_valid_reg.out ? 1'd1;
      stage2_valid.in = data_valid_reg.out ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out ? 1'd1;
      stage2_valid.in = !data_valid_reg.out ? 1'd0;
    }
    static<1> group static_if2<"promotable"=1> {
      out_valid.write_en = stage2_valid.out ? 1'd1;
      out_valid.in = stage2_valid.out ? 1'd1;
      out_valid.write_en = !stage2_valid.out ? 1'd1;
      out_valid.in = !stage2_valid.out ? 1'd0;
    }
    static<1> group static_par_thread0<"promotable"=1> {
      stage2_valid.write_en = data_valid_reg.out ? 1'd1;
      stage2_valid.in = data_valid_reg.out ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out ? 1'd1;
      stage2_valid.in = !data_valid_reg.out ? 1'd0;
      out_valid.write_en = stage2_valid.out ? 1'd1;
      out_valid.in = stage2_valid.out ? 1'd1;
      out_valid.write_en = !stage2_valid.out ? 1'd1;
      out_valid.in = !stage2_valid.out ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
  }
  wires {
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group store_a0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group no-op {
    }
    static<6> group invoke30 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    static<1> group invoke40 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    static<2> group no-op0 {
    }
    static<1> group invoke00 {
      idx0.write_en = 1'd1;
      idx0.in = 4'd0;
    }
    static<6> group invoke10 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    static<1> group invoke20 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.left = 4'd1;
      add0.right = idx0.out;
    }
    static<6> group invoke50 {
      mac.go = 1'd1;
      mac.c = mac.out;
    }
    static<1> group save_out0 {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
    }
    static<8> group static_seq {
      idx0.write_en = %0 ? 1'd1;
      idx0.in = %0 ? 4'd0;
      a.addr0 = %1 ? idx0.out;
      read_a.write_en = %1 ? 1'd1;
      read_a.in = %1 ? a.read_data;
      b.addr0 = %1 ? idx0.out;
      read_b.write_en = %1 ? 1'd1;
      read_b.in = %1 ? b.read_data;
      mac.go = %[2:8] ? 1'd1;
      mac.data_valid = %[2:8] ? 1'd1;
      mac.a = %[2:8] ? read_a.out;
      mac.b = %[2:8] ? read_b.out;
    }
    static<1> group static_par_thread<"promotable"=1> {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<3> group static_seq0 {
      idx0.write_en = %2 ? 1'd1;
      idx0.in = %2 ? add0.out;
      add0.left = %2 ? 4'd1;
      add0.right = %2 ? idx0.out;
    }
    static<8> group static_par_thread0<"promoted"=1> {
      idx0.write_en = %0 ? 1'd1;
      idx0.in = %0 ? 4'd0;
      a.addr0 = %1 ? idx0.out;
      read_a.write_en = %1 ? 1'd1;
      read_a.in = %1 ? a.read_data;
      b.addr0 = %1 ? idx0.out;
      read_b.write_en = %1 ? 1'd1;
      read_b.in = %1 ? b.read_data;
      mac.go = %[2:8] ? 1'd1;
      mac.data_valid = %[2:8] ? 1'd1;
      mac.a = %[2:8] ? read_a.out;
      mac.b = %[2:8] ? read_b.out;
      idx0.write_en = %2 & %[0:3] ? 1'd1;
      idx0.in = %2 & %[0:3] ? add0.out;
      add0.left = %2 & %[0:3] ? 4'd1;
      add0.right = %2 & %[0:3] ? idx0.out;
    }
    static<8> group static_seq1 {
      a.addr0 = %0 & %[0:7] ? idx0.out;
      read_a.write_en = %0 & %[0:7] ? 1'd1;
      read_a.in = %0 & %[0:7] ? a.read_data;
      b.addr0 = %0 & %[0:7] ? idx0.out;
      read_b.write_en = %0 & %[0:7] ? 1'd1;
      read_b.in = %0 & %[0:7] ? b.read_data;
      mac.go = %[1:7] & %[0:7] ? 1'd1;
      mac.data_valid = %[1:7] & %[0:7] ? 1'd1;
      mac.a = %[1:7] & %[0:7] ? read_a.out;
      mac.b = %[1:7] & %[0:7] ? read_b.out;
      mac.c = %[1:7] & %[0:7] ? mac.out;
      idx0.write_en = %1 & %[0:2] & %[0:7] ? 1'd1;
      idx0.in = %1 & %[0:2] & %[0:7] ? add0.out;
      add0.left = %1 & %[0:2] & %[0:7] ? 4'd1;
      add0.right = %1 & %[0:2] & %[0:7] ? idx0.out;
      lt0.left = %7 ? idx0.out;
      lt0.right = %7 ? 4'd10;
      comb_reg.in = %7 ? lt0.out;
      comb_reg.write_en = %7 ? 1'd1;
    }
    static<7> group static_seq2 {
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      mac.go = %[1:7] ? 1'd1;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.b = %[1:7] ? read_b.out;
      mac.c = %[1:7] ? mac.out;
    }
    static<1> group static_par_thread1<"promotable"=1> {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<2> group static_seq3 {
      idx0.write_en = %1 ? 1'd1;
      idx0.in = %1 ? add0.out;
      add0.left = %1 ? 4'd1;
      add0.right = %1 ? idx0.out;
    }
    static<7> group static_par_thread2<"promotable"=7, "promoted"=1> {
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      mac.go = %[1:7] ? 1'd1;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.b = %[1:7] ? read_b.out;
      mac.c = %[1:7] ? mac.out;
      idx0.write_en = %1 & %[0:2] ? 1'd1;
      idx0.in = %1 & %[0:2] ? add0.out;
      add0.left = %1 & %[0:2] ? 4'd1;
      add0.right = %1 & %[0:2] ? idx0.out;
    }
    static<7> group static_seq4 {
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
      out.addr0 = %6 ? 1'd0;
      out.write_en = %6 ? 1'd1;
      out.write_data = %6 ? mac.out;
    }
  }
  control {
    seq {
      static_par_thread0;
      in_range0;
      while comb_reg.out {
        static_seq1;
      }
      static_seq4;
    }
  }
}
Current pass: dead-group-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire.in = %1 & %[1:5] ? data_valid_reg.out;
      cond.write_en = %1 & %[1:5] ? 1'd1;
      cond_wire.in = %[2:5] & %[1:5] ? cond.out;
      mult_pipe.go = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      mult_pipe.left = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? a;
      mult_pipe.right = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? b;
      pipe1.write_en = %4 & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      pipe1.in = %4 & %[1:5] & cond_wire.out & %[1:5] ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 & %[1:5] ? 1'd1;
      pipe2.in = stage2_valid.out & %1 & %[1:5] ? add.out;
      add.left = stage2_valid.out & %1 & %[1:5] ? pipe1.out;
      add.right = stage2_valid.out & %1 & %[1:5] ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
  }
  wires {
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<8> group static_par_thread0<"promoted"=1> {
      idx0.write_en = %0 ? 1'd1;
      idx0.in = %0 ? 4'd0;
      a.addr0 = %1 ? idx0.out;
      read_a.write_en = %1 ? 1'd1;
      read_a.in = %1 ? a.read_data;
      b.addr0 = %1 ? idx0.out;
      read_b.write_en = %1 ? 1'd1;
      read_b.in = %1 ? b.read_data;
      mac.go = %[2:8] ? 1'd1;
      mac.data_valid = %[2:8] ? 1'd1;
      mac.a = %[2:8] ? read_a.out;
      mac.b = %[2:8] ? read_b.out;
      idx0.write_en = %2 & %[0:3] ? 1'd1;
      idx0.in = %2 & %[0:3] ? add0.out;
      add0.left = %2 & %[0:3] ? 4'd1;
      add0.right = %2 & %[0:3] ? idx0.out;
    }
    static<8> group static_seq1 {
      a.addr0 = %0 & %[0:7] ? idx0.out;
      read_a.write_en = %0 & %[0:7] ? 1'd1;
      read_a.in = %0 & %[0:7] ? a.read_data;
      b.addr0 = %0 & %[0:7] ? idx0.out;
      read_b.write_en = %0 & %[0:7] ? 1'd1;
      read_b.in = %0 & %[0:7] ? b.read_data;
      mac.go = %[1:7] & %[0:7] ? 1'd1;
      mac.data_valid = %[1:7] & %[0:7] ? 1'd1;
      mac.a = %[1:7] & %[0:7] ? read_a.out;
      mac.b = %[1:7] & %[0:7] ? read_b.out;
      mac.c = %[1:7] & %[0:7] ? mac.out;
      idx0.write_en = %1 & %[0:2] & %[0:7] ? 1'd1;
      idx0.in = %1 & %[0:2] & %[0:7] ? add0.out;
      add0.left = %1 & %[0:2] & %[0:7] ? 4'd1;
      add0.right = %1 & %[0:2] & %[0:7] ? idx0.out;
      lt0.left = %7 ? idx0.out;
      lt0.right = %7 ? 4'd10;
      comb_reg.in = %7 ? lt0.out;
      comb_reg.write_en = %7 ? 1'd1;
    }
    static<7> group static_seq4 {
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
      out.addr0 = %6 ? 1'd0;
      out.write_en = %6 ? 1'd1;
      out.write_data = %6 ? mac.out;
    }
  }
  control {
    seq {
      static_par_thread0;
      in_range0;
      while comb_reg.out {
        static_seq1;
      }
      static_seq4;
    }
  }
}
Current pass: dead-cell-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire.in = %1 & %[1:5] ? data_valid_reg.out;
      cond.write_en = %1 & %[1:5] ? 1'd1;
      cond_wire.in = %[2:5] & %[1:5] ? cond.out;
      mult_pipe.go = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      mult_pipe.left = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? a;
      mult_pipe.right = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? b;
      pipe1.write_en = %4 & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      pipe1.in = %4 & %[1:5] & cond_wire.out & %[1:5] ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 & %[1:5] ? 1'd1;
      pipe2.in = stage2_valid.out & %1 & %[1:5] ? add.out;
      add.left = stage2_valid.out & %1 & %[1:5] ? pipe1.out;
      add.right = stage2_valid.out & %1 & %[1:5] ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
  }
  wires {
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<8> group static_par_thread0<"promoted"=1> {
      idx0.write_en = %0 ? 1'd1;
      idx0.in = %0 ? 4'd0;
      a.addr0 = %1 ? idx0.out;
      read_a.write_en = %1 ? 1'd1;
      read_a.in = %1 ? a.read_data;
      b.addr0 = %1 ? idx0.out;
      read_b.write_en = %1 ? 1'd1;
      read_b.in = %1 ? b.read_data;
      mac.go = %[2:8] ? 1'd1;
      mac.data_valid = %[2:8] ? 1'd1;
      mac.a = %[2:8] ? read_a.out;
      mac.b = %[2:8] ? read_b.out;
      idx0.write_en = %2 & %[0:3] ? 1'd1;
      idx0.in = %2 & %[0:3] ? add0.out;
      add0.left = %2 & %[0:3] ? 4'd1;
      add0.right = %2 & %[0:3] ? idx0.out;
    }
    static<8> group static_seq1 {
      a.addr0 = %0 & %[0:7] ? idx0.out;
      read_a.write_en = %0 & %[0:7] ? 1'd1;
      read_a.in = %0 & %[0:7] ? a.read_data;
      b.addr0 = %0 & %[0:7] ? idx0.out;
      read_b.write_en = %0 & %[0:7] ? 1'd1;
      read_b.in = %0 & %[0:7] ? b.read_data;
      mac.go = %[1:7] & %[0:7] ? 1'd1;
      mac.data_valid = %[1:7] & %[0:7] ? 1'd1;
      mac.a = %[1:7] & %[0:7] ? read_a.out;
      mac.b = %[1:7] & %[0:7] ? read_b.out;
      mac.c = %[1:7] & %[0:7] ? mac.out;
      idx0.write_en = %1 & %[0:2] & %[0:7] ? 1'd1;
      idx0.in = %1 & %[0:2] & %[0:7] ? add0.out;
      add0.left = %1 & %[0:2] & %[0:7] ? 4'd1;
      add0.right = %1 & %[0:2] & %[0:7] ? idx0.out;
      lt0.left = %7 ? idx0.out;
      lt0.right = %7 ? 4'd10;
      comb_reg.in = %7 ? lt0.out;
      comb_reg.write_en = %7 ? 1'd1;
    }
    static<7> group static_seq4 {
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
      out.addr0 = %6 ? 1'd0;
      out.write_en = %6 ? 1'd1;
      out.write_data = %6 ? mac.out;
    }
  }
  control {
    seq {
      static_par_thread0;
      in_range0;
      while comb_reg.out {
        static_seq1;
      }
      static_seq4;
    }
  }
}
Current pass: add-guard
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %[0:6] & %0 ? 1'd1;
      data_valid_reg.in = %[0:6] & %0 ? data_valid;
      cond.in = %[0:6] & %[1:5] ? data_valid_reg.out;
      cond_wire.in = %[0:6] & %1 & %[1:5] ? data_valid_reg.out;
      cond.write_en = %[0:6] & %1 & %[1:5] ? 1'd1;
      cond_wire.in = %[0:6] & %[2:5] & %[1:5] ? cond.out;
      mult_pipe.go = %[0:6] & %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      mult_pipe.left = %[0:6] & %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? a;
      mult_pipe.right = %[0:6] & %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? b;
      pipe1.write_en = %[0:6] & %4 & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      pipe1.in = %[0:6] & %4 & %[1:5] & cond_wire.out & %[1:5] ? mult_pipe.out;
      pipe2.write_en = %[0:6] & stage2_valid.out & %1 & %[1:5] ? 1'd1;
      pipe2.in = %[0:6] & stage2_valid.out & %1 & %[1:5] ? add.out;
      add.left = %[0:6] & stage2_valid.out & %1 & %[1:5] ? pipe1.out;
      add.right = %[0:6] & stage2_valid.out & %1 & %[1:5] ? c;
      stage2_valid.write_en = %[0:6] & data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = %[0:6] & data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = %[0:6] & !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = %[0:6] & !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = %[0:6] & stage2_valid.out & %5 ? 1'd1;
      out_valid.in = %[0:6] & stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = %[0:6] & !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = %[0:6] & !stage2_valid.out & %5 ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
  }
  wires {
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<8> group static_par_thread0<"promoted"=1> {
      idx0.write_en = %0 ? 1'd1;
      idx0.in = %0 ? 4'd0;
      a.addr0 = %1 ? idx0.out;
      read_a.write_en = %1 ? 1'd1;
      read_a.in = %1 ? a.read_data;
      b.addr0 = %1 ? idx0.out;
      read_b.write_en = %1 ? 1'd1;
      read_b.in = %1 ? b.read_data;
      mac.go = %[2:8] ? 1'd1;
      mac.data_valid = %[2:8] ? 1'd1;
      mac.a = %[2:8] ? read_a.out;
      mac.b = %[2:8] ? read_b.out;
      idx0.write_en = %2 & %[0:3] ? 1'd1;
      idx0.in = %2 & %[0:3] ? add0.out;
      add0.left = %2 & %[0:3] ? 4'd1;
      add0.right = %2 & %[0:3] ? idx0.out;
    }
    static<8> group static_seq1 {
      a.addr0 = %0 & %[0:7] ? idx0.out;
      read_a.write_en = %0 & %[0:7] ? 1'd1;
      read_a.in = %0 & %[0:7] ? a.read_data;
      b.addr0 = %0 & %[0:7] ? idx0.out;
      read_b.write_en = %0 & %[0:7] ? 1'd1;
      read_b.in = %0 & %[0:7] ? b.read_data;
      mac.go = %[1:7] & %[0:7] ? 1'd1;
      mac.data_valid = %[1:7] & %[0:7] ? 1'd1;
      mac.a = %[1:7] & %[0:7] ? read_a.out;
      mac.b = %[1:7] & %[0:7] ? read_b.out;
      mac.c = %[1:7] & %[0:7] ? mac.out;
      idx0.write_en = %1 & %[0:2] & %[0:7] ? 1'd1;
      idx0.in = %1 & %[0:2] & %[0:7] ? add0.out;
      add0.left = %1 & %[0:2] & %[0:7] ? 4'd1;
      add0.right = %1 & %[0:2] & %[0:7] ? idx0.out;
      lt0.left = %7 ? idx0.out;
      lt0.right = %7 ? 4'd10;
      comb_reg.in = %7 ? lt0.out;
      comb_reg.write_en = %7 ? 1'd1;
    }
    static<7> group static_seq4 {
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
      out.addr0 = %6 ? 1'd0;
      out.write_en = %6 ? 1'd1;
      out.write_data = %6 ? mac.out;
    }
  }
  control {
    seq {
      static_par_thread0;
      in_range0;
      while comb_reg.out {
        static_seq1;
      }
      static_seq4;
    }
  }
}
Current pass: simplify-static-guards
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire.in = %1 ? data_valid_reg.out;
      cond.write_en = %1 ? 1'd1;
      cond_wire.in = %[2:5] ? cond.out;
      mult_pipe.go = cond_wire.out & %[1:4] ? 1'd1;
      mult_pipe.left = cond_wire.out & %[1:4] ? a;
      mult_pipe.right = cond_wire.out & %[1:4] ? b;
      pipe1.write_en = cond_wire.out & %4 ? 1'd1;
      pipe1.in = cond_wire.out & %4 ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 ? 1'd1;
      pipe2.in = stage2_valid.out & %1 ? add.out;
      add.left = stage2_valid.out & %1 ? pipe1.out;
      add.right = stage2_valid.out & %1 ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
  }
  wires {
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<8> group static_par_thread0<"promoted"=1> {
      idx0.write_en = %0 ? 1'd1;
      idx0.in = %0 ? 4'd0;
      a.addr0 = %1 ? idx0.out;
      read_a.write_en = %1 ? 1'd1;
      read_a.in = %1 ? a.read_data;
      b.addr0 = %1 ? idx0.out;
      read_b.write_en = %1 ? 1'd1;
      read_b.in = %1 ? b.read_data;
      mac.go = %[2:8] ? 1'd1;
      mac.data_valid = %[2:8] ? 1'd1;
      mac.a = %[2:8] ? read_a.out;
      mac.b = %[2:8] ? read_b.out;
      idx0.write_en = %2 ? 1'd1;
      idx0.in = %2 ? add0.out;
      add0.left = %2 ? 4'd1;
      add0.right = %2 ? idx0.out;
    }
    static<8> group static_seq1 {
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      mac.go = %[1:7] ? 1'd1;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.b = %[1:7] ? read_b.out;
      mac.c = %[1:7] ? mac.out;
      idx0.write_en = %1 ? 1'd1;
      idx0.in = %1 ? add0.out;
      add0.left = %1 ? 4'd1;
      add0.right = %1 ? idx0.out;
      lt0.left = %7 ? idx0.out;
      lt0.right = %7 ? 4'd10;
      comb_reg.in = %7 ? lt0.out;
      comb_reg.write_en = %7 ? 1'd1;
    }
    static<7> group static_seq4 {
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
      out.addr0 = %6 ? 1'd0;
      out.write_en = %6 ? 1'd1;
      out.write_data = %6 ? mac.out;
    }
  }
  control {
    seq {
      static_par_thread0;
      in_range0;
      while comb_reg.out {
        static_seq1;
      }
      static_seq4;
    }
  }
}
Current pass: dead-group-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire.in = %1 ? data_valid_reg.out;
      cond.write_en = %1 ? 1'd1;
      cond_wire.in = %[2:5] ? cond.out;
      mult_pipe.go = cond_wire.out & %[1:4] ? 1'd1;
      mult_pipe.left = cond_wire.out & %[1:4] ? a;
      mult_pipe.right = cond_wire.out & %[1:4] ? b;
      pipe1.write_en = cond_wire.out & %4 ? 1'd1;
      pipe1.in = cond_wire.out & %4 ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 ? 1'd1;
      pipe2.in = stage2_valid.out & %1 ? add.out;
      add.left = stage2_valid.out & %1 ? pipe1.out;
      add.right = stage2_valid.out & %1 ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
  }
  wires {
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<8> group static_par_thread0<"promoted"=1> {
      idx0.write_en = %0 ? 1'd1;
      idx0.in = %0 ? 4'd0;
      a.addr0 = %1 ? idx0.out;
      read_a.write_en = %1 ? 1'd1;
      read_a.in = %1 ? a.read_data;
      b.addr0 = %1 ? idx0.out;
      read_b.write_en = %1 ? 1'd1;
      read_b.in = %1 ? b.read_data;
      mac.go = %[2:8] ? 1'd1;
      mac.data_valid = %[2:8] ? 1'd1;
      mac.a = %[2:8] ? read_a.out;
      mac.b = %[2:8] ? read_b.out;
      idx0.write_en = %2 ? 1'd1;
      idx0.in = %2 ? add0.out;
      add0.left = %2 ? 4'd1;
      add0.right = %2 ? idx0.out;
    }
    static<8> group static_seq1 {
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      mac.go = %[1:7] ? 1'd1;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.b = %[1:7] ? read_b.out;
      mac.c = %[1:7] ? mac.out;
      idx0.write_en = %1 ? 1'd1;
      idx0.in = %1 ? add0.out;
      add0.left = %1 ? 4'd1;
      add0.right = %1 ? idx0.out;
      lt0.left = %7 ? idx0.out;
      lt0.right = %7 ? 4'd10;
      comb_reg.in = %7 ? lt0.out;
      comb_reg.write_en = %7 ? 1'd1;
    }
    static<7> group static_seq4 {
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
      out.addr0 = %6 ? 1'd0;
      out.write_en = %6 ? 1'd1;
      out.write_data = %6 ? mac.out;
    }
  }
  control {
    seq {
      static_par_thread0;
      in_range0;
      while comb_reg.out {
        static_seq1;
      }
      static_seq4;
    }
  }
}
Current pass: assign-node-id
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire.in = %1 ? data_valid_reg.out;
      cond.write_en = %1 ? 1'd1;
      cond_wire.in = %[2:5] ? cond.out;
      mult_pipe.go = cond_wire.out & %[1:4] ? 1'd1;
      mult_pipe.left = cond_wire.out & %[1:4] ? a;
      mult_pipe.right = cond_wire.out & %[1:4] ? b;
      pipe1.write_en = cond_wire.out & %4 ? 1'd1;
      pipe1.in = cond_wire.out & %4 ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 ? 1'd1;
      pipe2.in = stage2_valid.out & %1 ? add.out;
      add.left = stage2_valid.out & %1 ? pipe1.out;
      add.right = stage2_valid.out & %1 ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    @NODE_ID(0) static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
  }
  wires {
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<8> group static_par_thread0<"promoted"=1> {
      idx0.write_en = %0 ? 1'd1;
      idx0.in = %0 ? 4'd0;
      a.addr0 = %1 ? idx0.out;
      read_a.write_en = %1 ? 1'd1;
      read_a.in = %1 ? a.read_data;
      b.addr0 = %1 ? idx0.out;
      read_b.write_en = %1 ? 1'd1;
      read_b.in = %1 ? b.read_data;
      mac.go = %[2:8] ? 1'd1;
      mac.data_valid = %[2:8] ? 1'd1;
      mac.a = %[2:8] ? read_a.out;
      mac.b = %[2:8] ? read_b.out;
      idx0.write_en = %2 ? 1'd1;
      idx0.in = %2 ? add0.out;
      add0.left = %2 ? 4'd1;
      add0.right = %2 ? idx0.out;
    }
    static<8> group static_seq1 {
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      mac.go = %[1:7] ? 1'd1;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.b = %[1:7] ? read_b.out;
      mac.c = %[1:7] ? mac.out;
      idx0.write_en = %1 ? 1'd1;
      idx0.in = %1 ? add0.out;
      add0.left = %1 ? 4'd1;
      add0.right = %1 ? idx0.out;
      lt0.left = %7 ? idx0.out;
      lt0.right = %7 ? 4'd10;
      comb_reg.in = %7 ? lt0.out;
      comb_reg.write_en = %7 ? 1'd1;
    }
    static<7> group static_seq4 {
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
      out.addr0 = %6 ? 1'd0;
      out.write_en = %6 ? 1'd1;
      out.write_data = %6 ? mac.out;
    }
  }
  control {
    seq {
      @NODE_ID(0) static_par_thread0;
      @NODE_ID(9) in_range0;
      while comb_reg.out {
        @NODE_ID(11) static_seq1;
      }
      @NODE_ID(20) static_seq4;
    }
  }
}
Current pass: dfsm
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire.in = %1 ? data_valid_reg.out;
      cond.write_en = %1 ? 1'd1;
      cond_wire.in = %[2:5] ? cond.out;
      mult_pipe.go = cond_wire.out & %[1:4] ? 1'd1;
      mult_pipe.left = cond_wire.out & %[1:4] ? a;
      mult_pipe.right = cond_wire.out & %[1:4] ? b;
      pipe1.write_en = cond_wire.out & %4 ? 1'd1;
      pipe1.in = cond_wire.out & %4 ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 ? 1'd1;
      pipe2.in = stage2_valid.out & %1 ? add.out;
      add.left = stage2_valid.out & %1 ? pipe1.out;
      add.right = stage2_valid.out & %1 ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {} => 8,
      8 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    pipe1.write_en = cond_wire.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
  }
  control {
    fsm;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    fsm_mac_a = std_wire(32);
    fsm_mac_b = std_wire(32);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @write_together @data fsm_comb_reg_in = std_wire(1);
    @write_together @interval @go fsm_comb_reg_write_en = std_wire(1);
    fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
  }
  wires {
    static<1> group in_range0 {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<8> group static_par_thread0<"promoted"=1> {
      idx0.write_en = %0 ? 1'd1;
      idx0.in = %0 ? 4'd0;
      a.addr0 = %1 ? idx0.out;
      read_a.write_en = %1 ? 1'd1;
      read_a.in = %1 ? a.read_data;
      b.addr0 = %1 ? idx0.out;
      read_b.write_en = %1 ? 1'd1;
      read_b.in = %1 ? b.read_data;
      mac.go = %[2:8] ? 1'd1;
      mac.data_valid = %[2:8] ? 1'd1;
      mac.a = %[2:8] ? read_a.out;
      mac.b = %[2:8] ? read_b.out;
      idx0.write_en = %2 ? 1'd1;
      idx0.in = %2 ? add0.out;
      add0.left = %2 ? 4'd1;
      add0.right = %2 ? idx0.out;
    }
    static<8> group static_seq1 {
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      mac.go = %[1:7] ? 1'd1;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.b = %[1:7] ? read_b.out;
      mac.c = %[1:7] ? mac.out;
      idx0.write_en = %1 ? 1'd1;
      idx0.in = %1 ? add0.out;
      add0.left = %1 ? 4'd1;
      add0.right = %1 ? idx0.out;
      lt0.left = %7 ? idx0.out;
      lt0.right = %7 ? 4'd10;
      comb_reg.in = %7 ? lt0.out;
      comb_reg.write_en = %7 ? 1'd1;
    }
    static<7> group static_seq4 {
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
      out.addr0 = %6 ? 1'd0;
      out.write_en = %6 ? 1'd1;
      out.write_data = %6 ? mac.out;
    }
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = 4'd0;
      } => 2,
      2 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 3,
      3 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 4,
      4 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 5,
      5 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 6,
      6 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 7,
      7 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 8,
      8 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 9,
      9 : {} => 10,
      10 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 11,
      11 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 11,
      },
      12 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 13,
      13 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 14,
      14 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 15,
      15 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 16,
      16 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 17,
      17 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 18,
      18 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 19,
      19 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 20,
      20 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 20,
      },
      21 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 22,
      22 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 23,
      23 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 24,
      24 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 25,
      25 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 26,
      26 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 27,
      27 : {
        fsm_out_addr0.in = 1'd0;
        fsm_out_write_en.in = 1'd1;
        fsm_out_write_data.in = mac.out;
      } => 28,
      28 : {} => 29,
      29 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    out.addr0 = fsm_out_addr0.out;
    out.write_en = fsm_out_write_en.out;
    out.write_data = fsm_out_write_data.out;
  }
  control {
    fsm;
  }
}
Current pass: dead-group-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {} => 8,
      8 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    pipe1.write_en = cond_wire.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
  }
  control {
    fsm;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    fsm_mac_a = std_wire(32);
    fsm_mac_b = std_wire(32);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @write_together @data fsm_comb_reg_in = std_wire(1);
    @write_together @interval @go fsm_comb_reg_write_en = std_wire(1);
    fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = 4'd0;
      } => 2,
      2 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 3,
      3 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 4,
      4 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 5,
      5 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 6,
      6 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 7,
      7 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 8,
      8 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 9,
      9 : {} => 10,
      10 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 11,
      11 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 11,
      },
      12 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 13,
      13 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 14,
      14 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 15,
      15 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 16,
      16 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 17,
      17 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 18,
      18 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 19,
      19 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 20,
      20 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 20,
      },
      21 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 22,
      22 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 23,
      23 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 24,
      24 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 25,
      25 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 26,
      26 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 27,
      27 : {
        fsm_out_addr0.in = 1'd0;
        fsm_out_write_en.in = 1'd1;
        fsm_out_write_data.in = mac.out;
      } => 28,
      28 : {} => 29,
      29 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    out.addr0 = fsm_out_addr0.out;
    out.write_en = fsm_out_write_en.out;
    out.write_data = fsm_out_write_data.out;
  }
  control {
    fsm;
  }
}
Current pass: wrap-main
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {} => 8,
      8 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    pipe1.write_en = cond_wire.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
  }
  control {
    fsm;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    fsm_mac_a = std_wire(32);
    fsm_mac_b = std_wire(32);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @write_together @data fsm_comb_reg_in = std_wire(1);
    @write_together @interval @go fsm_comb_reg_write_en = std_wire(1);
    fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = 4'd0;
      } => 2,
      2 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 3,
      3 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 4,
      4 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 5,
      5 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 6,
      6 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 7,
      7 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 8,
      8 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 9,
      9 : {} => 10,
      10 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 11,
      11 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 11,
      },
      12 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 13,
      13 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 14,
      14 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 15,
      15 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 16,
      16 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 17,
      17 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 18,
      18 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 19,
      19 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 20,
      20 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 20,
      },
      21 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 22,
      22 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 23,
      23 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 24,
      24 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 25,
      25 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 26,
      26 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 27,
      27 : {
        fsm_out_addr0.in = 1'd0;
        fsm_out_write_en.in = 1'd1;
        fsm_out_write_data.in = mac.out;
      } => 28,
      28 : {} => 29,
      29 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    out.addr0 = fsm_out_addr0.out;
    out.write_en = fsm_out_write_en.out;
    out.write_data = fsm_out_write_data.out;
  }
  control {
    fsm;
  }
}
Current pass: go-insertion
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {} => 8,
      8 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    pipe1.write_en = cond_wire.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
  }
  control {
    fsm;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    fsm_mac_a = std_wire(32);
    fsm_mac_b = std_wire(32);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @write_together @data fsm_comb_reg_in = std_wire(1);
    @write_together @interval @go fsm_comb_reg_write_en = std_wire(1);
    fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm[start] -> 1,
        default -> 0,
      },
      1 : {
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = 4'd0;
      } => 2,
      2 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 3,
      3 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 4,
      4 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 5,
      5 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 6,
      6 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 7,
      7 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 8,
      8 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 9,
      9 : {} => 10,
      10 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 11,
      11 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 11,
      },
      12 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 13,
      13 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 14,
      14 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 15,
      15 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 16,
      16 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 17,
      17 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 18,
      18 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 19,
      19 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 20,
      20 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 20,
      },
      21 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 22,
      22 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 23,
      23 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 24,
      24 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 25,
      25 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 26,
      26 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 27,
      27 : {
        fsm_out_addr0.in = 1'd0;
        fsm_out_write_en.in = 1'd1;
        fsm_out_write_data.in = mac.out;
      } => 28,
      28 : {} => 29,
      29 : {
        fsm[done] = 1'd1;
      } => 0,
    }
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    out.addr0 = fsm_out_addr0.out;
    out.write_en = fsm_out_write_en.out;
    out.write_data = fsm_out_write_data.out;
  }
  control {
    fsm;
  }
}
Current pass: wire-inliner
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {} => 8,
      8 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    pipe1.write_en = cond_wire.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
    fsm_start.in = go;
    done = fsm_done.out ? 1'd1;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    fsm_mac_a = std_wire(32);
    fsm_mac_b = std_wire(32);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @write_together @data fsm_comb_reg_in = std_wire(1);
    @write_together @interval @go fsm_comb_reg_write_en = std_wire(1);
    fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = 4'd0;
      } => 2,
      2 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 3,
      3 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 4,
      4 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 5,
      5 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 6,
      6 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 7,
      7 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 8,
      8 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 9,
      9 : {} => 10,
      10 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 11,
      11 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 11,
      },
      12 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 13,
      13 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 14,
      14 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 15,
      15 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 16,
      16 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 17,
      17 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 18,
      18 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 19,
      19 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 20,
      20 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 20,
      },
      21 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 22,
      22 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 23,
      23 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 24,
      24 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 25,
      25 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 26,
      26 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 27,
      27 : {
        fsm_out_addr0.in = 1'd0;
        fsm_out_write_en.in = 1'd1;
        fsm_out_write_data.in = mac.out;
      } => 28,
      28 : {} => 29,
      29 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    out.addr0 = fsm_out_addr0.out;
    out.write_en = fsm_out_write_en.out;
    out.write_data = fsm_out_write_data.out;
    fsm_start.in = go;
    done = fsm_done.out ? 1'd1;
  }
  control {}
}
Current pass: clk-insertion
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {} => 8,
      8 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    pipe1.write_en = cond_wire.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
    fsm_start.in = go;
    done = fsm_done.out ? 1'd1;
    mult_pipe.clk = clk;
    pipe1.clk = clk;
    pipe2.clk = clk;
    stage2_valid.clk = clk;
    out_valid.clk = clk;
    data_valid_reg.clk = clk;
    cond.clk = clk;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    fsm_mac_a = std_wire(32);
    fsm_mac_b = std_wire(32);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @write_together @data fsm_comb_reg_in = std_wire(1);
    @write_together @interval @go fsm_comb_reg_write_en = std_wire(1);
    fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = 4'd0;
      } => 2,
      2 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 3,
      3 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 4,
      4 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 5,
      5 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 6,
      6 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 7,
      7 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 8,
      8 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 9,
      9 : {} => 10,
      10 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 11,
      11 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 11,
      },
      12 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 13,
      13 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 14,
      14 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 15,
      15 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 16,
      16 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 17,
      17 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 18,
      18 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 19,
      19 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 20,
      20 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 20,
      },
      21 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 22,
      22 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 23,
      23 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 24,
      24 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 25,
      25 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 26,
      26 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 27,
      27 : {
        fsm_out_addr0.in = 1'd0;
        fsm_out_write_en.in = 1'd1;
        fsm_out_write_data.in = mac.out;
      } => 28,
      28 : {} => 29,
      29 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    out.addr0 = fsm_out_addr0.out;
    out.write_en = fsm_out_write_en.out;
    out.write_data = fsm_out_write_data.out;
    fsm_start.in = go;
    done = fsm_done.out ? 1'd1;
    a.clk = clk;
    b.clk = clk;
    out.clk = clk;
    read_a.clk = clk;
    read_b.clk = clk;
    idx0.clk = clk;
    mac.clk = clk;
    comb_reg.clk = clk;
  }
  control {}
}
Current pass: reset-insertion
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {} => 8,
      8 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    output_valid = out_valid.out;
    out = pipe2.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    cond.write_en = fsm_cond_write_en.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    cond.in = fsm_cond_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    pipe1.write_en = cond_wire.out ? fsm_pipe1_write_en.out;
    pipe1.in = cond_wire.out ? fsm_pipe1_in.out;
    stage2_valid.write_en = data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = data_valid_reg.out ? fsm_stage2_valid_in.out;
    stage2_valid.write_en = !data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.in = !data_valid_reg.out ? fsm_stage2_valid_in.out;
    out_valid.write_en = stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = stage2_valid.out ? fsm_out_valid_in.out;
    out_valid.write_en = !stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.in = !stage2_valid.out ? fsm_out_valid_in.out;
    fsm_start.in = go;
    done = fsm_done.out ? 1'd1;
    mult_pipe.clk = clk;
    pipe1.clk = clk;
    pipe2.clk = clk;
    stage2_valid.clk = clk;
    out_valid.clk = clk;
    data_valid_reg.clk = clk;
    cond.clk = clk;
    mult_pipe.reset = reset;
    pipe1.reset = reset;
    pipe2.reset = reset;
    stage2_valid.reset = reset;
    out_valid.reset = reset;
    data_valid_reg.reset = reset;
    cond.reset = reset;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    fsm_mac_a = std_wire(32);
    fsm_mac_b = std_wire(32);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @write_together @data fsm_comb_reg_in = std_wire(1);
    @write_together @interval @go fsm_comb_reg_write_en = std_wire(1);
    fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = 4'd0;
      } => 2,
      2 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 3,
      3 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 4,
      4 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 5,
      5 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 6,
      6 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 7,
      7 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 8,
      8 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 9,
      9 : {} => 10,
      10 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 11,
      11 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 11,
      },
      12 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 13,
      13 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 14,
      14 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 15,
      15 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 16,
      16 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 17,
      17 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 18,
      18 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 19,
      19 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 20,
      20 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 20,
      },
      21 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 22,
      22 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 23,
      23 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 24,
      24 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 25,
      25 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 26,
      26 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 27,
      27 : {
        fsm_out_addr0.in = 1'd0;
        fsm_out_write_en.in = 1'd1;
        fsm_out_write_data.in = mac.out;
      } => 28,
      28 : {} => 29,
      29 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    a.addr0 = fsm_a_addr0.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.in = fsm_read_a_in.out;
    b.addr0 = fsm_b_addr0.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.in = fsm_read_b_in.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.in = fsm_idx0_in.out;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.a = fsm_mac_a.out;
    mac.b = fsm_mac_b.out;
    mac.c = fsm_mac_c.out;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    comb_reg.in = fsm_comb_reg_in.out;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    mac.go = fsm_mac_go.out;
    mac.c = fsm_mac_c.out;
    out.addr0 = fsm_out_addr0.out;
    out.write_en = fsm_out_write_en.out;
    out.write_data = fsm_out_write_data.out;
    fsm_start.in = go;
    done = fsm_done.out ? 1'd1;
    a.clk = clk;
    b.clk = clk;
    out.clk = clk;
    read_a.clk = clk;
    read_b.clk = clk;
    idx0.clk = clk;
    mac.clk = clk;
    comb_reg.clk = clk;
    a.reset = reset;
    b.reset = reset;
    out.reset = reset;
    read_a.reset = reset;
    read_b.reset = reset;
    idx0.reset = reset;
    mac.reset = reset;
    comb_reg.reset = reset;
  }
  control {}
}
Current pass: merge-assigns
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {} => 8,
      8 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    done = fsm_done.out ? 1'd1;
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm_cond_write_en.out;
    cond.clk = clk;
    cond.reset = reset;
    cond.in = fsm_cond_in.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.clk = clk;
    pipe2.reset = reset;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    out_valid.write_en = !stage2_valid.out | stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.clk = clk;
    out_valid.reset = reset;
    out_valid.in = !stage2_valid.out | stage2_valid.out ? fsm_out_valid_in.out;
    mult_pipe.clk = clk;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.reset = reset;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.clk = clk;
    data_valid_reg.reset = reset;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    stage2_valid.write_en = !data_valid_reg.out | data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.clk = clk;
    stage2_valid.reset = reset;
    stage2_valid.in = !data_valid_reg.out | data_valid_reg.out ? fsm_stage2_valid_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    pipe1.write_en = cond_wire.out ? fsm_pipe1_write_en.out;
    pipe1.clk = clk;
    pipe1.reset = reset;
    pipe1.in = cond_wire.out ? fsm_pipe1_in.out;
    fsm_start.in = go;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    fsm_mac_a = std_wire(32);
    fsm_mac_b = std_wire(32);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @write_together @data fsm_comb_reg_in = std_wire(1);
    @write_together @interval @go fsm_comb_reg_write_en = std_wire(1);
    fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = 4'd0;
      } => 2,
      2 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 3,
      3 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 4,
      4 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 5,
      5 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 6,
      6 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 7,
      7 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 8,
      8 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 9,
      9 : {} => 10,
      10 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 11,
      11 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 11,
      },
      12 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 13,
      13 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 14,
      14 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 15,
      15 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 16,
      16 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 17,
      17 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 18,
      18 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 19,
      19 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 20,
      20 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 20,
      },
      21 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 22,
      22 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 23,
      23 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 24,
      24 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 25,
      25 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 26,
      26 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 27,
      27 : {
        fsm_out_addr0.in = 1'd0;
        fsm_out_write_en.in = 1'd1;
        fsm_out_write_data.in = mac.out;
      } => 28,
      28 : {} => 29,
      29 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    done = fsm_done.out ? 1'd1;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    b.clk = clk;
    b.addr0 = fsm_b_addr0.out;
    b.reset = reset;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    comb_reg.clk = clk;
    comb_reg.reset = reset;
    comb_reg.in = fsm_comb_reg_in.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.clk = clk;
    read_b.reset = reset;
    read_b.in = fsm_read_b_in.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.clk = clk;
    idx0.reset = reset;
    idx0.in = fsm_idx0_in.out;
    a.clk = clk;
    a.addr0 = fsm_a_addr0.out;
    a.reset = reset;
    out.write_en = fsm_out_write_en.out;
    out.clk = clk;
    out.addr0 = fsm_out_addr0.out;
    out.reset = reset;
    out.write_data = fsm_out_write_data.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.clk = clk;
    read_a.reset = reset;
    read_a.in = fsm_read_a_in.out;
    mac.b = fsm_mac_b.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.clk = clk;
    mac.a = fsm_mac_a.out;
    mac.go = fsm_mac_go.out;
    mac.reset = reset;
    mac.c = fsm_mac_c.out;
    fsm_start.in = go;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
  }
  control {}
}
Current pass: default-assigns
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, a: 32, b: 32, c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @write_together @interval @go fsm_data_valid_reg_write_en = std_wire(1);
    @write_together @data fsm_data_valid_reg_in = std_wire(1);
    @write_together @data fsm_cond_in = std_wire(1);
    @data fsm_cond_wire_in = std_wire(1);
    @write_together @interval @go fsm_cond_write_en = std_wire(1);
    @write_together @interval(3) @go fsm_mult_pipe_go = std_wire(1);
    @write_together @data fsm_mult_pipe_left = std_wire(32);
    @write_together @data fsm_mult_pipe_right = std_wire(32);
    @write_together @interval @go fsm_pipe2_write_en = std_wire(1);
    @write_together @data fsm_pipe2_in = std_wire(32);
    @data fsm_add_left = std_wire(32);
    @data fsm_add_right = std_wire(32);
    @write_together @interval @go fsm_pipe1_write_en = std_wire(1);
    @write_together @data fsm_pipe1_in = std_wire(32);
    @write_together @interval @go fsm_stage2_valid_write_en = std_wire(1);
    @write_together @data fsm_stage2_valid_in = std_wire(1);
    @write_together @interval @go fsm_out_valid_write_en = std_wire(1);
    @write_together @data fsm_out_valid_in = std_wire(1);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_data_valid_reg_write_en.in = 1'd1;
        fsm_data_valid_reg_in.in = data_valid;
      } => 2,
      2 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = data_valid_reg.out;
        fsm_cond_write_en.in = 1'd1;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
        fsm_pipe2_write_en.in = stage2_valid.out ? 1'd1;
        fsm_pipe2_in.in = stage2_valid.out ? add.out;
        fsm_add_left.in = stage2_valid.out ? pipe1.out;
        fsm_add_right.in = stage2_valid.out ? c;
      } => 3,
      3 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 4,
      4 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_mult_pipe_go.in = cond_wire.out ? 1'd1;
        fsm_mult_pipe_left.in = cond_wire.out ? a;
        fsm_mult_pipe_right.in = cond_wire.out ? b;
      } => 5,
      5 : {
        fsm_cond_in.in = data_valid_reg.out;
        fsm_cond_wire_in.in = cond.out;
        fsm_pipe1_write_en.in = cond_wire.out ? 1'd1;
        fsm_pipe1_in.in = cond_wire.out ? mult_pipe.out;
      } => 6,
      6 : {
        fsm_stage2_valid_write_en.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_write_en.in = !data_valid_reg.out ? 1'd1;
        fsm_stage2_valid_in.in = !data_valid_reg.out ? 1'd0;
        fsm_out_valid_write_en.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = stage2_valid.out ? 1'd1;
        fsm_out_valid_write_en.in = !stage2_valid.out ? 1'd1;
        fsm_out_valid_in.in = !stage2_valid.out ? 1'd0;
      } => 7,
      7 : {} => 8,
      8 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    done = fsm_done.out ? 1'd1;
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm_cond_write_en.out;
    cond.clk = clk;
    cond.reset = reset;
    cond.in = fsm_cond_in.out;
    pipe2.write_en = stage2_valid.out ? fsm_pipe2_write_en.out;
    pipe2.clk = clk;
    pipe2.reset = reset;
    pipe2.in = stage2_valid.out ? fsm_pipe2_in.out;
    out_valid.write_en = !stage2_valid.out | stage2_valid.out ? fsm_out_valid_write_en.out;
    out_valid.clk = clk;
    out_valid.reset = reset;
    out_valid.in = !stage2_valid.out | stage2_valid.out ? fsm_out_valid_in.out;
    mult_pipe.clk = clk;
    mult_pipe.left = cond_wire.out ? fsm_mult_pipe_left.out;
    mult_pipe.go = cond_wire.out ? fsm_mult_pipe_go.out;
    mult_pipe.reset = reset;
    mult_pipe.right = cond_wire.out ? fsm_mult_pipe_right.out;
    data_valid_reg.write_en = fsm_data_valid_reg_write_en.out;
    data_valid_reg.clk = clk;
    data_valid_reg.reset = reset;
    data_valid_reg.in = fsm_data_valid_reg_in.out;
    add.left = stage2_valid.out ? fsm_add_left.out;
    add.right = stage2_valid.out ? fsm_add_right.out;
    stage2_valid.write_en = !data_valid_reg.out | data_valid_reg.out ? fsm_stage2_valid_write_en.out;
    stage2_valid.clk = clk;
    stage2_valid.reset = reset;
    stage2_valid.in = !data_valid_reg.out | data_valid_reg.out ? fsm_stage2_valid_in.out;
    cond_wire.in = fsm_cond_wire_in.out;
    pipe1.write_en = cond_wire.out ? fsm_pipe1_write_en.out;
    pipe1.clk = clk;
    pipe1.reset = reset;
    pipe1.in = cond_wire.out ? fsm_pipe1_in.out;
    fsm_start.in = go;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @write_together @interval @go fsm_idx0_write_en = std_wire(1);
    @write_together @data fsm_idx0_in = std_wire(4);
    @read_together fsm_a_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_a_write_en = std_wire(1);
    @write_together @data fsm_read_a_in = std_wire(32);
    @read_together fsm_b_addr0 = std_wire(4);
    @write_together @interval @go fsm_read_b_write_en = std_wire(1);
    @write_together @data fsm_read_b_in = std_wire(32);
    @go fsm_mac_go = std_wire(1);
    fsm_mac_data_valid = std_wire(1);
    fsm_mac_a = std_wire(32);
    fsm_mac_b = std_wire(32);
    @data fsm_add0_left = std_wire(4);
    @data fsm_add0_right = std_wire(4);
    @data fsm_lt0_left = std_wire(4);
    @data fsm_lt0_right = std_wire(4);
    @write_together @data fsm_comb_reg_in = std_wire(1);
    @write_together @interval @go fsm_comb_reg_write_en = std_wire(1);
    fsm_mac_c = std_wire(32);
    @read_together fsm_out_addr0 = std_wire(1);
    @write_together @interval @go fsm_out_write_en = std_wire(1);
    @write_together @data fsm_out_write_data = std_wire(32);
    @go @generated fsm_start = std_wire(1);
    @done @generated fsm_done = std_wire(1);
  }
  wires {
    fsm fsm {
      0 : {} => {
        fsm_start.out -> 1,
        default -> 0,
      },
      1 : {
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = 4'd0;
      } => 2,
      2 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 3,
      3 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 4,
      4 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 5,
      5 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 6,
      6 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 7,
      7 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 8,
      8 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
      } => 9,
      9 : {} => 10,
      10 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 11,
      11 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 11,
      },
      12 : {
        fsm_a_addr0.in = idx0.out;
        fsm_read_a_write_en.in = 1'd1;
        fsm_read_a_in.in = a.read_data;
        fsm_b_addr0.in = idx0.out;
        fsm_read_b_write_en.in = 1'd1;
        fsm_read_b_in.in = b.read_data;
      } => 13,
      13 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
        fsm_idx0_write_en.in = 1'd1;
        fsm_idx0_in.in = add0.out;
        fsm_add0_left.in = 4'd1;
        fsm_add0_right.in = idx0.out;
      } => 14,
      14 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 15,
      15 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 16,
      16 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 17,
      17 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 18,
      18 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_data_valid.in = 1'd1;
        fsm_mac_a.in = read_a.out;
        fsm_mac_b.in = read_b.out;
        fsm_mac_c.in = mac.out;
      } => 19,
      19 : {
        fsm_lt0_left.in = idx0.out;
        fsm_lt0_right.in = 4'd10;
        fsm_comb_reg_in.in = lt0.out;
        fsm_comb_reg_write_en.in = 1'd1;
      } => 20,
      20 : {} => {
        comb_reg.out -> 12,
        !comb_reg.out -> 21,
        default -> 20,
      },
      21 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 22,
      22 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 23,
      23 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 24,
      24 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 25,
      25 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 26,
      26 : {
        fsm_mac_go.in = 1'd1;
        fsm_mac_c.in = mac.out;
      } => 27,
      27 : {
        fsm_out_addr0.in = 1'd0;
        fsm_out_write_en.in = 1'd1;
        fsm_out_write_data.in = mac.out;
      } => 28,
      28 : {} => 29,
      29 : {
        fsm_done.in = 1'd1;
      } => 0,
    }
    done = fsm_done.out ? 1'd1;
    add0.left = fsm_add0_left.out;
    add0.right = fsm_add0_right.out;
    b.clk = clk;
    b.addr0 = fsm_b_addr0.out;
    b.reset = reset;
    comb_reg.write_en = fsm_comb_reg_write_en.out;
    comb_reg.clk = clk;
    comb_reg.reset = reset;
    comb_reg.in = fsm_comb_reg_in.out;
    read_b.write_en = fsm_read_b_write_en.out;
    read_b.clk = clk;
    read_b.reset = reset;
    read_b.in = fsm_read_b_in.out;
    idx0.write_en = fsm_idx0_write_en.out;
    idx0.clk = clk;
    idx0.reset = reset;
    idx0.in = fsm_idx0_in.out;
    a.clk = clk;
    a.addr0 = fsm_a_addr0.out;
    a.reset = reset;
    out.write_en = fsm_out_write_en.out;
    out.clk = clk;
    out.addr0 = fsm_out_addr0.out;
    out.reset = reset;
    out.write_data = fsm_out_write_data.out;
    read_a.write_en = fsm_read_a_write_en.out;
    read_a.clk = clk;
    read_a.reset = reset;
    read_a.in = fsm_read_a_in.out;
    mac.b = fsm_mac_b.out;
    mac.data_valid = fsm_mac_data_valid.out;
    mac.clk = clk;
    mac.a = fsm_mac_a.out;
    mac.go = fsm_mac_go.out;
    mac.reset = reset;
    mac.c = fsm_mac_c.out;
    fsm_start.in = go;
    lt0.left = fsm_lt0_left.out;
    lt0.right = fsm_lt0_right.out;
    a.write_en = 1'd0;
    b.write_en = 1'd0;
  }
  control {}
}
