Current pass: well-formed
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    mult_pipe = std_mult_pipe(32);
    add = std_add(32);
    pipe1 = std_reg(32);
    pipe2 = std_reg(32);
    stage2_valid = std_reg(1);
    out_valid = std_reg(1);
    data_valid_reg = std_reg(1);
  }
  wires {
    group stage1<"static"=4> {
      mult_pipe.left = a;
      mult_pipe.right = b;
      pipe1.in = mult_pipe.out;
      pipe1.write_en = mult_pipe.done;
      mult_pipe.go = !mult_pipe.done ? 1'd1;
      stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          stage1;
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external a = comb_mem_d1(32, 10, 4);
    @external b = comb_mem_d1(32, 10, 4);
    @external out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    lt0 = std_lt(4);
    mac = pipelined_mac();
  }
  wires {
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: papercut
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    mult_pipe = std_mult_pipe(32);
    add = std_add(32);
    pipe1 = std_reg(32);
    pipe2 = std_reg(32);
    stage2_valid = std_reg(1);
    out_valid = std_reg(1);
    data_valid_reg = std_reg(1);
  }
  wires {
    group stage1<"static"=4> {
      mult_pipe.left = a;
      mult_pipe.right = b;
      pipe1.in = mult_pipe.out;
      pipe1.write_en = mult_pipe.done;
      mult_pipe.go = !mult_pipe.done ? 1'd1;
      stage1[done] = pipe1.done;
    }
    group stage2 {
      add.left = pipe1.out;
      add.right = c;
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.in = 1'd1;
      stage2_valid.write_en = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.in = 1'd0;
      stage2_valid.write_en = 1'd1;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.in = 1'd1;
      out_valid.write_en = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.in = 1'd0;
      out_valid.write_en = 1'd1;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
      write_data_valid[done] = data_valid_reg.done;
    }
    output_valid = out_valid.out;
    out = pipe2.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          stage1;
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external a = comb_mem_d1(32, 10, 4);
    @external b = comb_mem_d1(32, 10, 4);
    @external out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    lt0 = std_lt(4);
    mac = pipelined_mac();
  }
  wires {
    group store_a {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      idx0.in = add0.out;
      idx0.write_en = 1'd1;
      add0.left = 4'd1;
      add0.right = idx0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.addr0 = 1'd0;
      out.write_en = 1'd1;
      out.write_data = mac.out;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: canonicalize
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    mult_pipe = std_mult_pipe(32);
    add = std_add(32);
    pipe1 = std_reg(32);
    pipe2 = std_reg(32);
    stage2_valid = std_reg(1);
    out_valid = std_reg(1);
    data_valid_reg = std_reg(1);
  }
  wires {
    group stage1<"static"=4> {
      mult_pipe.go = !mult_pipe.done ? 1'd1;
      pipe1.write_en = mult_pipe.done;
      pipe1.in = mult_pipe.out;
      mult_pipe.right = b;
      mult_pipe.left = a;
      stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          stage1;
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external a = comb_mem_d1(32, 10, 4);
    @external b = comb_mem_d1(32, 10, 4);
    @external out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    lt0 = std_lt(4);
    mac = pipelined_mac();
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: infer-data-path
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group stage1<"static"=4> {
      mult_pipe.go = !mult_pipe.done ? 1'd1;
      pipe1.write_en = mult_pipe.done;
      pipe1.in = mult_pipe.out;
      mult_pipe.right = b;
      mult_pipe.left = a;
      stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          stage1;
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: collapse-control
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group stage1<"static"=4> {
      mult_pipe.go = !mult_pipe.done ? 1'd1;
      pipe1.write_en = mult_pipe.done;
      pipe1.in = mult_pipe.out;
      mult_pipe.right = b;
      mult_pipe.left = a;
      stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          stage1;
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: compile-sync-without-sync-reg
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group stage1<"static"=4> {
      mult_pipe.go = !mult_pipe.done ? 1'd1;
      pipe1.write_en = mult_pipe.done;
      pipe1.in = mult_pipe.out;
      mult_pipe.right = b;
      mult_pipe.left = a;
      stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          stage1;
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: group2seq
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          seq {
            beg_spl_stage1;
            end_spl_stage1;
          }
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: dead-assign-removal
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    seq {
      write_data_valid;
      par {
        if data_valid_reg.out {
          seq {
            beg_spl_stage1;
            end_spl_stage1;
          }
        }
        if stage2_valid.out {
          stage2;
        }
      }
      par {
        if data_valid_reg.out {
          set_stage2_valid;
        } else {
          unset_stage2_valid;
        }
        if stage2_valid.out {
          set_out_valid;
        } else {
          unset_out_valid;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      incr_idx;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          incr_idx;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: group2invoke
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.right = c;
      add.left = pipe1.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    seq {
      invoke data_valid_reg(
        in = data_valid
      )();
      par {
        if data_valid_reg.out {
          seq {
            invoke mult_pipe(
              right = b,
              left = a
            )();
            invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        if stage2_valid.out {
          invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      par {
        if data_valid_reg.out {
          invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          invoke stage2_valid(
            in = 1'd0
          )();
        }
        if stage2_valid.out {
          invoke out_valid(
            in = 1'd1
          )();
        } else {
          invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
    comb group comb_invoke {
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: infer-share
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.right = c;
      add.left = pipe1.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    @NODE_ID(0) seq {
      @NODE_ID invoke data_valid_reg(
        in = data_valid
      )();
      @NODE_ID(2) par {
        @BEGIN_ID(3) @END_ID(7) if data_valid_reg.out {
          @NODE_ID(4) seq {
            @NODE_ID(5) invoke mult_pipe(
              right = b,
              left = a
            )();
            @NODE_ID(6) invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        @BEGIN_ID(8) @END_ID(10) if stage2_valid.out {
          @NODE_ID(9) invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      @NODE_ID(11) par {
        @BEGIN_ID(12) @END_ID(15) if data_valid_reg.out {
          @NODE_ID(13) invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(14) invoke stage2_valid(
            in = 1'd0
          )();
        }
        @BEGIN_ID(16) @END_ID(19) if stage2_valid.out {
          @NODE_ID(17) invoke out_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(18) invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
    comb group comb_invoke {
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: inline
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.right = c;
      add.left = pipe1.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    @NODE_ID(0) seq {
      @NODE_ID invoke data_valid_reg(
        in = data_valid
      )();
      @NODE_ID(2) par {
        @BEGIN_ID(3) @END_ID(7) if data_valid_reg.out {
          @NODE_ID(4) seq {
            @NODE_ID(5) invoke mult_pipe(
              right = b,
              left = a
            )();
            @NODE_ID(6) invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        @BEGIN_ID(8) @END_ID(10) if stage2_valid.out {
          @NODE_ID(9) invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      @NODE_ID(11) par {
        @BEGIN_ID(12) @END_ID(15) if data_valid_reg.out {
          @NODE_ID(13) invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(14) invoke stage2_valid(
            in = 1'd0
          )();
        }
        @BEGIN_ID(16) @END_ID(19) if stage2_valid.out {
          @NODE_ID(17) invoke out_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(18) invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
    comb group comb_invoke {
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: comb-prop
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.right = c;
      add.left = pipe1.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    @NODE_ID(0) seq {
      @NODE_ID invoke data_valid_reg(
        in = data_valid
      )();
      @NODE_ID(2) par {
        @BEGIN_ID(3) @END_ID(7) if data_valid_reg.out {
          @NODE_ID(4) seq {
            @NODE_ID(5) invoke mult_pipe(
              right = b,
              left = a
            )();
            @NODE_ID(6) invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        @BEGIN_ID(8) @END_ID(10) if stage2_valid.out {
          @NODE_ID(9) invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      @NODE_ID(11) par {
        @BEGIN_ID(12) @END_ID(15) if data_valid_reg.out {
          @NODE_ID(13) invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(14) invoke stage2_valid(
            in = 1'd0
          )();
        }
        @BEGIN_ID(16) @END_ID(19) if stage2_valid.out {
          @NODE_ID(17) invoke out_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(18) invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
    comb group comb_invoke {
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: constant-port-prop
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.right = c;
      add.left = pipe1.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    @NODE_ID(0) seq {
      @NODE_ID invoke data_valid_reg(
        in = data_valid
      )();
      @NODE_ID(2) par {
        @BEGIN_ID(3) @END_ID(7) if data_valid_reg.out {
          @NODE_ID(4) seq {
            @NODE_ID(5) invoke mult_pipe(
              right = b,
              left = a
            )();
            @NODE_ID(6) invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        @BEGIN_ID(8) @END_ID(10) if stage2_valid.out {
          @NODE_ID(9) invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      @NODE_ID(11) par {
        @BEGIN_ID(12) @END_ID(15) if data_valid_reg.out {
          @NODE_ID(13) invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(14) invoke stage2_valid(
            in = 1'd0
          )();
        }
        @BEGIN_ID(16) @END_ID(19) if stage2_valid.out {
          @NODE_ID(17) invoke out_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(18) invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data read_c = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
    comb group comb_invoke {
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: dead-cell-removal
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.right = c;
      add.left = pipe1.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    @NODE_ID(0) seq {
      @NODE_ID invoke data_valid_reg(
        in = data_valid
      )();
      @NODE_ID(2) par {
        @BEGIN_ID(3) @END_ID(7) if data_valid_reg.out {
          @NODE_ID(4) seq {
            @NODE_ID(5) invoke mult_pipe(
              right = b,
              left = a
            )();
            @NODE_ID(6) invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        @BEGIN_ID(8) @END_ID(10) if stage2_valid.out {
          @NODE_ID(9) invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      @NODE_ID(11) par {
        @BEGIN_ID(12) @END_ID(15) if data_valid_reg.out {
          @NODE_ID(13) invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(14) invoke stage2_valid(
            in = 1'd0
          )();
        }
        @BEGIN_ID(16) @END_ID(19) if stage2_valid.out {
          @NODE_ID(17) invoke out_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(18) invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
    comb group comb_invoke {
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
  }
  control {
    seq {
      par {
        store_a;
        store_b;
      }
      invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      invoke idx0(
        in = add0.out
      )() with comb_invoke;
      while lt0.out with in_range {
        seq {
          par {
            store_a;
            store_b;
          }
          invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      invoke mac(
        c = mac.out
      )();
      save_out;
    }
  }
}
Current pass: cell-share
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    comb group comb_invoke {
      add.right = c;
      add.left = pipe1.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    @NODE_ID(0) seq {
      @NODE_ID invoke data_valid_reg(
        in = data_valid
      )();
      @NODE_ID(2) par {
        @BEGIN_ID(3) @END_ID(7) @NODE_ID(3) if data_valid_reg.out {
          @NODE_ID(4) seq {
            @NODE_ID(5) invoke mult_pipe(
              right = b,
              left = a
            )();
            @NODE_ID(6) invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        @BEGIN_ID(8) @END_ID(10) @NODE_ID(8) if stage2_valid.out {
          @NODE_ID(9) invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      @NODE_ID(11) par {
        @BEGIN_ID(12) @END_ID(15) @NODE_ID(12) if data_valid_reg.out {
          @NODE_ID(13) invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(14) invoke stage2_valid(
            in = 1'd0
          )();
        }
        @BEGIN_ID(16) @END_ID(19) @NODE_ID(16) if stage2_valid.out {
          @NODE_ID(17) invoke out_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(18) invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
    comb group comb_invoke {
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
  }
  control {
    @NODE_ID(0) seq {
      @NODE_ID par {
        @NODE_ID(2) store_a;
        @NODE_ID(3) store_b;
      }
      @NODE_ID(4) invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      @NODE_ID(5) invoke idx0(
        in = add0.out
      )() with comb_invoke;
      @NODE_ID(6) while lt0.out with in_range {
        @NODE_ID(7) seq {
          @NODE_ID(8) par {
            @NODE_ID(9) store_a;
            @NODE_ID(10) store_b;
          }
          @NODE_ID(11) invoke mac(
            data_valid = 1'd1,
            a = read_a.out,
            b = read_b.out,
            c = mac.out
          )();
          @NODE_ID(12) invoke idx0(
            in = add0.out
          )() with comb_invoke;
        }
      }
      @NODE_ID(13) invoke mac(
        c = mac.out
      )();
      @NODE_ID(14) save_out;
    }
  }
}
Current pass: simplify-with-control
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    static<1> group comb_invoke0 {
      add.right = c;
      add.left = pipe1.out;
      comb_reg.in = add.out;
      comb_reg.write_en = 1'd1;
    }
    comb group comb_invoke {
      add.right = c;
      add.left = pipe1.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    @NODE_ID(0) seq {
      @NODE_ID invoke data_valid_reg(
        in = data_valid
      )();
      @NODE_ID(2) par {
        @BEGIN_ID(3) @END_ID(7) @NODE_ID(3) if data_valid_reg.out {
          @NODE_ID(4) seq {
            @NODE_ID(5) invoke mult_pipe(
              right = b,
              left = a
            )();
            @NODE_ID(6) invoke pipe1(
              in = mult_pipe.out
            )();
          }
        }
        @BEGIN_ID(8) @END_ID(10) @NODE_ID(8) if stage2_valid.out {
          @NODE_ID(9) invoke pipe2(
            in = add.out
          )() with comb_invoke;
        }
      }
      @NODE_ID(11) par {
        @BEGIN_ID(12) @END_ID(15) @NODE_ID(12) if data_valid_reg.out {
          @NODE_ID(13) invoke stage2_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(14) invoke stage2_valid(
            in = 1'd0
          )();
        }
        @BEGIN_ID(16) @END_ID(19) @NODE_ID(16) if stage2_valid.out {
          @NODE_ID(17) invoke out_valid(
            in = 1'd1
          )();
        } else {
          @NODE_ID(18) invoke out_valid(
            in = 1'd0
          )();
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    static<1> group in_range0 {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group comb_invoke0 {
      add0.right = idx0.out;
      add0.left = 4'd1;
      comb_reg0.in = add0.out;
      comb_reg0.write_en = 1'd1;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
    comb group comb_invoke {
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
  }
  control {
    @NODE_ID(0) seq {
      @NODE_ID par {
        @NODE_ID(2) store_a;
        @NODE_ID(3) store_b;
      }
      @NODE_ID(4) invoke mac(
        data_valid = 1'd1,
        a = read_a.out,
        b = read_b.out
      )();
      @NODE_ID(5) invoke idx0(
        in = add0.out
      )() with comb_invoke;
      seq {
        in_range0;
        @NODE_ID(6) while comb_reg.out {
          seq {
            @NODE_ID(7) seq {
              @NODE_ID(8) par {
                @NODE_ID(9) store_a;
                @NODE_ID(10) store_b;
              }
              @NODE_ID(11) invoke mac(
                data_valid = 1'd1,
                a = read_a.out,
                b = read_b.out,
                c = mac.out
              )();
              @NODE_ID(12) invoke idx0(
                in = add0.out
              )() with comb_invoke;
            }
            in_range0;
          }
        }
      }
      @NODE_ID(13) invoke mac(
        c = mac.out
      )();
      @NODE_ID(14) save_out;
    }
  }
}
Current pass: compile-invoke
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
  }
  wires {
    group beg_spl_stage1 {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1 {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2 {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    group invoke0 {
      data_valid_reg.write_en = 1'd1;
      invoke0[done] = data_valid_reg.done;
      data_valid_reg.in = data_valid;
    }
    group invoke1 {
      mult_pipe.go = 1'd1;
      invoke1[done] = mult_pipe.done;
      mult_pipe.right = b;
      mult_pipe.left = a;
    }
    group invoke2 {
      pipe1.write_en = 1'd1;
      invoke2[done] = pipe1.done;
      pipe1.in = mult_pipe.out;
    }
    group invoke3 {
      pipe2.write_en = 1'd1;
      invoke3[done] = pipe2.done;
      pipe2.in = add.out;
      add.right = c;
      add.left = pipe1.out;
    }
    group invoke4 {
      stage2_valid.write_en = 1'd1;
      invoke4[done] = stage2_valid.done;
      stage2_valid.in = 1'd1;
    }
    group invoke5 {
      stage2_valid.write_en = 1'd1;
      invoke5[done] = stage2_valid.done;
      stage2_valid.in = 1'd0;
    }
    group invoke6 {
      out_valid.write_en = 1'd1;
      invoke6[done] = out_valid.done;
      out_valid.in = 1'd1;
    }
    group invoke7 {
      out_valid.write_en = 1'd1;
      invoke7[done] = out_valid.done;
      out_valid.in = 1'd0;
    }
    static<1> group comb_invoke0 {
      add.right = c;
      add.left = pipe1.out;
      comb_reg.in = add.out;
      comb_reg.write_en = 1'd1;
    }
    comb group comb_invoke {
      add.right = c;
      add.left = pipe1.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    @NODE_ID(0) seq {
      @NODE_ID invoke0;
      @NODE_ID(2) par {
        @BEGIN_ID(3) @END_ID(7) @NODE_ID(3) if data_valid_reg.out {
          @NODE_ID(4) seq {
            @NODE_ID(5) invoke1;
            @NODE_ID(6) invoke2;
          }
        }
        @BEGIN_ID(8) @END_ID(10) @NODE_ID(8) if stage2_valid.out {
          @NODE_ID(9) invoke3;
        }
      }
      @NODE_ID(11) par {
        @BEGIN_ID(12) @END_ID(15) @NODE_ID(12) if data_valid_reg.out {
          @NODE_ID(13) invoke4;
        } else {
          @NODE_ID(14) invoke5;
        }
        @BEGIN_ID(16) @END_ID(19) @NODE_ID(16) if stage2_valid.out {
          @NODE_ID(17) invoke6;
        } else {
          @NODE_ID(18) invoke7;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    group store_a {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    group invoke0 {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1 {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    group invoke2 {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3 {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    group invoke4 {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group comb_invoke0 {
      add0.right = idx0.out;
      add0.left = 4'd1;
      comb_reg0.in = add0.out;
      comb_reg0.write_en = 1'd1;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
    comb group comb_invoke {
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
  }
  control {
    @NODE_ID(0) seq {
      @NODE_ID par {
        @NODE_ID(2) store_a;
        @NODE_ID(3) store_b;
      }
      @NODE_ID(4) invoke0;
      @NODE_ID(5) invoke1;
      seq {
        in_range0;
        @NODE_ID(6) while comb_reg.out {
          seq {
            @NODE_ID(7) seq {
              @NODE_ID(8) par {
                @NODE_ID(9) store_a;
                @NODE_ID(10) store_b;
              }
              @NODE_ID(11) invoke2;
              @NODE_ID(12) invoke3;
            }
            in_range0;
          }
        }
      }
      @NODE_ID(13) invoke4;
      @NODE_ID(14) save_out;
    }
  }
}
Current pass: static-inference
component pipelined_mac(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go @promotable(6) go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
  }
  wires {
    group beg_spl_stage1<"promotable"=3> {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1<"promotable"=1> {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2<"promotable"=1> {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid<"promotable"=1> {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid<"promotable"=1> {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid<"promotable"=1> {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    group invoke0<"promotable"=1> {
      data_valid_reg.write_en = 1'd1;
      invoke0[done] = data_valid_reg.done;
      data_valid_reg.in = data_valid;
    }
    group invoke1<"promotable"=3> {
      mult_pipe.go = 1'd1;
      invoke1[done] = mult_pipe.done;
      mult_pipe.right = b;
      mult_pipe.left = a;
    }
    group invoke2<"promotable"=1> {
      pipe1.write_en = 1'd1;
      invoke2[done] = pipe1.done;
      pipe1.in = mult_pipe.out;
    }
    group invoke3<"promotable"=1> {
      pipe2.write_en = 1'd1;
      invoke3[done] = pipe2.done;
      pipe2.in = add.out;
      add.right = c;
      add.left = pipe1.out;
    }
    group invoke4<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke4[done] = stage2_valid.done;
      stage2_valid.in = 1'd1;
    }
    group invoke5<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke5[done] = stage2_valid.done;
      stage2_valid.in = 1'd0;
    }
    group invoke6<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke6[done] = out_valid.done;
      out_valid.in = 1'd1;
    }
    group invoke7<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke7[done] = out_valid.done;
      out_valid.in = 1'd0;
    }
    static<1> group comb_invoke0 {
      add.right = c;
      add.left = pipe1.out;
      comb_reg.in = add.out;
      comb_reg.write_en = 1'd1;
    }
    comb group comb_invoke {
      add.right = c;
      add.left = pipe1.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    @NODE_ID(0) @promotable(6) seq {
      @NODE_ID @promotable invoke0;
      @NODE_ID(2) @promotable(4) par {
        @BEGIN_ID(3) @END_ID(7) @NODE_ID(3) @promotable(4) if data_valid_reg.out {
          @NODE_ID(4) @promotable(4) seq {
            @NODE_ID(5) @promotable(3) invoke1;
            @NODE_ID(6) @promotable invoke2;
          }
        }
        @BEGIN_ID(8) @END_ID(10) @NODE_ID(8) @promotable if stage2_valid.out {
          @NODE_ID(9) @promotable invoke3;
        }
      }
      @NODE_ID(11) @promotable par {
        @BEGIN_ID(12) @END_ID(15) @NODE_ID(12) @promotable if data_valid_reg.out {
          @NODE_ID(13) @promotable invoke4;
        } else {
          @NODE_ID(14) @promotable invoke5;
        }
        @BEGIN_ID(16) @END_ID(19) @NODE_ID(16) @promotable if stage2_valid.out {
          @NODE_ID(17) @promotable invoke6;
        } else {
          @NODE_ID(18) @promotable invoke7;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    group store_a<"promotable"=1> {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b<"promotable"=1> {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx<"promotable"=1> {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out<"promotable"=1> {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    group invoke0<"promotable"=6> {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    group invoke2<"promotable"=6> {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    group invoke4<"promotable"=6> {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group comb_invoke0 {
      add0.right = idx0.out;
      add0.left = 4'd1;
      comb_reg0.in = add0.out;
      comb_reg0.write_en = 1'd1;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
    comb group comb_invoke {
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
  }
  control {
    @NODE_ID(0) seq {
      @NODE_ID @promotable par {
        @NODE_ID(2) @promotable store_a;
        @NODE_ID(3) @promotable store_b;
      }
      @NODE_ID(4) @promotable(6) invoke0;
      @NODE_ID(5) @promotable invoke1;
      seq {
        @promotable in_range0;
        @NODE_ID(6) while comb_reg.out {
          @promotable(9) seq {
            @NODE_ID(7) @promotable(8) seq {
              @NODE_ID(8) @promotable par {
                @NODE_ID(9) @promotable store_a;
                @NODE_ID(10) @promotable store_b;
              }
              @NODE_ID(11) @promotable(6) invoke2;
              @NODE_ID(12) @promotable invoke3;
            }
            @promotable in_range0;
          }
        }
      }
      @NODE_ID(13) @promotable(6) invoke4;
      @NODE_ID(14) @promotable save_out;
    }
  }
}
Current pass: static-promotion
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
  }
  wires {
    group beg_spl_stage1<"promotable"=3> {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1<"promotable"=1> {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2<"promotable"=1> {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid<"promotable"=1> {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid<"promotable"=1> {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid<"promotable"=1> {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    group invoke0<"promotable"=1> {
      data_valid_reg.write_en = 1'd1;
      invoke0[done] = data_valid_reg.done;
      data_valid_reg.in = data_valid;
    }
    group invoke1<"promotable"=3> {
      mult_pipe.go = 1'd1;
      invoke1[done] = mult_pipe.done;
      mult_pipe.right = b;
      mult_pipe.left = a;
    }
    group invoke2<"promotable"=1> {
      pipe1.write_en = 1'd1;
      invoke2[done] = pipe1.done;
      pipe1.in = mult_pipe.out;
    }
    group invoke3<"promotable"=1> {
      pipe2.write_en = 1'd1;
      invoke3[done] = pipe2.done;
      pipe2.in = add.out;
      add.right = c;
      add.left = pipe1.out;
    }
    group invoke4<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke4[done] = stage2_valid.done;
      stage2_valid.in = 1'd1;
    }
    group invoke5<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke5[done] = stage2_valid.done;
      stage2_valid.in = 1'd0;
    }
    group invoke6<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke6[done] = out_valid.done;
      out_valid.in = 1'd1;
    }
    group invoke7<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke7[done] = out_valid.done;
      out_valid.in = 1'd0;
    }
    static<1> group comb_invoke0 {
      add.right = c;
      add.left = pipe1.out;
      comb_reg.in = add.out;
      comb_reg.write_en = 1'd1;
    }
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.right = b;
      mult_pipe.left = a;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.right = c;
      add.left = pipe1.out;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    comb group comb_invoke {
      add.right = c;
      add.left = pipe1.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    static<6> seq  {
      @NODE_ID invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            @NODE_ID(5) invoke10;
            @NODE_ID(6) invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          @NODE_ID(9) invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          @NODE_ID(13) invoke40;
        } else {
          @NODE_ID(14) invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          @NODE_ID(17) invoke60;
        } else {
          @NODE_ID(18) invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    group store_a<"promotable"=1> {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b<"promotable"=1> {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx<"promotable"=1> {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out<"promotable"=1> {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    group invoke0<"promotable"=6> {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    group invoke2<"promotable"=6> {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    group invoke4<"promotable"=6> {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group comb_invoke0 {
      add0.right = idx0.out;
      add0.left = 4'd1;
      comb_reg0.in = add0.out;
      comb_reg0.write_en = 1'd1;
    }
    static<1> group store_a0 {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
    }
    static<1> group no-op {
    }
    static<6> group invoke20 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    static<1> group invoke30 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    static<1> group no-op0 {
    }
    static<6> group invoke00 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    static<1> group invoke10 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    static<6> group invoke40 {
      mac.go = 1'd1;
      mac.c = mac.out;
    }
    static<1> group save_out0 {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
    comb group comb_invoke {
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
  }
  control {
    seq {
      @promoted static<7> par {
        static<7> seq  {
          @promotable static<1> par {
            @NODE_ID(2) store_a0;
            @NODE_ID(3) store_b0;
          }
          @NODE_ID(4) invoke00;
        }
        static<2> seq  {
          no-op0;
          @NODE_ID(5) invoke10;
        }
      }
      seq {
        in_range0;
        @NODE_ID(6) while comb_reg.out {
          static<8> seq  {
            @promotable(7) @promoted static<7> par {
              static<7> seq  {
                @promotable static<1> par {
                  @NODE_ID(9) store_a0;
                  @NODE_ID(10) store_b0;
                }
                @NODE_ID(11) invoke20;
              }
              static<2> seq  {
                no-op;
                @NODE_ID(12) invoke30;
              }
            }
            @promotable in_range0;
          }
        }
      }
      static<7> seq  {
        @NODE_ID(13) invoke40;
        @NODE_ID(14) save_out0;
      }
    }
  }
}
Current pass: compile-repeat
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
  }
  wires {
    group beg_spl_stage1<"promotable"=3> {
      mult_pipe.right = b;
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      beg_spl_stage1[done] = mult_pipe.done;
    }
    group end_spl_stage1<"promotable"=1> {
      pipe1.in = mult_pipe.out;
      pipe1.write_en = 1'd1;
      end_spl_stage1[done] = pipe1.done;
    }
    group stage2<"promotable"=1> {
      pipe2.write_en = 1'd1;
      add.right = c;
      add.left = pipe1.out;
      pipe2.in = add.out;
      stage2[done] = pipe2.done;
    }
    group set_stage2_valid<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
      set_stage2_valid[done] = stage2_valid.done;
    }
    group unset_stage2_valid<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
      unset_stage2_valid[done] = stage2_valid.done;
    }
    group set_out_valid<"promotable"=1> {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
      set_out_valid[done] = out_valid.done;
    }
    group unset_out_valid<"promotable"=1> {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
      unset_out_valid[done] = out_valid.done;
    }
    group write_data_valid<"promotable"=1> {
      data_valid_reg.in = data_valid;
      data_valid_reg.write_en = 1'd1;
      write_data_valid[done] = data_valid_reg.done;
    }
    group invoke0<"promotable"=1> {
      data_valid_reg.write_en = 1'd1;
      invoke0[done] = data_valid_reg.done;
      data_valid_reg.in = data_valid;
    }
    group invoke1<"promotable"=3> {
      mult_pipe.go = 1'd1;
      invoke1[done] = mult_pipe.done;
      mult_pipe.right = b;
      mult_pipe.left = a;
    }
    group invoke2<"promotable"=1> {
      pipe1.write_en = 1'd1;
      invoke2[done] = pipe1.done;
      pipe1.in = mult_pipe.out;
    }
    group invoke3<"promotable"=1> {
      pipe2.write_en = 1'd1;
      invoke3[done] = pipe2.done;
      pipe2.in = add.out;
      add.right = c;
      add.left = pipe1.out;
    }
    group invoke4<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke4[done] = stage2_valid.done;
      stage2_valid.in = 1'd1;
    }
    group invoke5<"promotable"=1> {
      stage2_valid.write_en = 1'd1;
      invoke5[done] = stage2_valid.done;
      stage2_valid.in = 1'd0;
    }
    group invoke6<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke6[done] = out_valid.done;
      out_valid.in = 1'd1;
    }
    group invoke7<"promotable"=1> {
      out_valid.write_en = 1'd1;
      invoke7[done] = out_valid.done;
      out_valid.in = 1'd0;
    }
    static<1> group comb_invoke0 {
      add.right = c;
      add.left = pipe1.out;
      comb_reg.in = add.out;
      comb_reg.write_en = 1'd1;
    }
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.right = b;
      mult_pipe.left = a;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.right = c;
      add.left = pipe1.out;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    comb group comb_invoke {
      add.right = c;
      add.left = pipe1.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    static<6> seq  {
      @NODE_ID invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            @NODE_ID(5) invoke10;
            @NODE_ID(6) invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          @NODE_ID(9) invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          @NODE_ID(13) invoke40;
        } else {
          @NODE_ID(14) invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          @NODE_ID(17) invoke60;
        } else {
          @NODE_ID(18) invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    group store_a<"promotable"=1> {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      store_a[done] = read_a.done;
    }
    group store_b<"promotable"=1> {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
      store_b[done] = read_b.done;
    }
    group incr_idx<"promotable"=1> {
      add0.right = idx0.out;
      add0.left = 4'd1;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      incr_idx[done] = idx0.done;
    }
    group save_out<"promotable"=1> {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      save_out[done] = out.done;
    }
    group invoke0<"promotable"=6> {
      mac.go = 1'd1;
      invoke0[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    group invoke1<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke1[done] = idx0.done;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    group invoke2<"promotable"=6> {
      mac.go = 1'd1;
      invoke2[done] = mac.done;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    group invoke3<"promotable"=1> {
      idx0.write_en = 1'd1;
      invoke3[done] = idx0.done;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    group invoke4<"promotable"=6> {
      mac.go = 1'd1;
      invoke4[done] = mac.done;
      mac.c = mac.out;
    }
    static<1> group in_range0 {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group comb_invoke0 {
      add0.right = idx0.out;
      add0.left = 4'd1;
      comb_reg0.in = add0.out;
      comb_reg0.write_en = 1'd1;
    }
    static<1> group store_a0 {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
    }
    static<1> group no-op {
    }
    static<6> group invoke20 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    static<1> group invoke30 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    static<1> group no-op0 {
    }
    static<6> group invoke00 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    static<1> group invoke10 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    static<6> group invoke40 {
      mac.go = 1'd1;
      mac.c = mac.out;
    }
    static<1> group save_out0 {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
    }
    comb group in_range {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
    }
    comb group comb_invoke {
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
  }
  control {
    seq {
      @promoted static<7> par {
        static<7> seq  {
          @promotable static<1> par {
            @NODE_ID(2) store_a0;
            @NODE_ID(3) store_b0;
          }
          @NODE_ID(4) invoke00;
        }
        static<2> seq  {
          no-op0;
          @NODE_ID(5) invoke10;
        }
      }
      seq {
        in_range0;
        @NODE_ID(6) while comb_reg.out {
          static<8> seq  {
            @promotable(7) @promoted static<7> par {
              static<7> seq  {
                @promotable static<1> par {
                  @NODE_ID(9) store_a0;
                  @NODE_ID(10) store_b0;
                }
                @NODE_ID(11) invoke20;
              }
              static<2> seq  {
                no-op;
                @NODE_ID(12) invoke30;
              }
            }
            @promotable in_range0;
          }
        }
      }
      static<7> seq  {
        @NODE_ID(13) invoke40;
        @NODE_ID(14) save_out0;
      }
    }
  }
}
Current pass: dead-group-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
  }
  wires {
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.right = b;
      mult_pipe.left = a;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.right = c;
      add.left = pipe1.out;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    static<6> seq  {
      @NODE_ID invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            @NODE_ID(5) invoke10;
            @NODE_ID(6) invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          @NODE_ID(9) invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          @NODE_ID(13) invoke40;
        } else {
          @NODE_ID(14) invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          @NODE_ID(17) invoke60;
        } else {
          @NODE_ID(18) invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    static<1> group in_range0 {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group store_a0 {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
    }
    static<1> group no-op {
    }
    static<6> group invoke20 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    static<1> group invoke30 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    static<1> group no-op0 {
    }
    static<6> group invoke00 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    static<1> group invoke10 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    static<6> group invoke40 {
      mac.go = 1'd1;
      mac.c = mac.out;
    }
    static<1> group save_out0 {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
    }
  }
  control {
    seq {
      @promoted static<7> par {
        static<7> seq  {
          @promotable static<1> par {
            @NODE_ID(2) store_a0;
            @NODE_ID(3) store_b0;
          }
          @NODE_ID(4) invoke00;
        }
        static<2> seq  {
          no-op0;
          @NODE_ID(5) invoke10;
        }
      }
      seq {
        in_range0;
        @NODE_ID(6) while comb_reg.out {
          static<8> seq  {
            @promotable(7) @promoted static<7> par {
              static<7> seq  {
                @promotable static<1> par {
                  @NODE_ID(9) store_a0;
                  @NODE_ID(10) store_b0;
                }
                @NODE_ID(11) invoke20;
              }
              static<2> seq  {
                no-op;
                @NODE_ID(12) invoke30;
              }
            }
            @promotable in_range0;
          }
        }
      }
      static<7> seq  {
        @NODE_ID(13) invoke40;
        @NODE_ID(14) save_out0;
      }
    }
  }
}
Current pass: collapse-control
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
  }
  wires {
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.right = b;
      mult_pipe.left = a;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.right = c;
      add.left = pipe1.out;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    static<6> seq  {
      @NODE_ID invoke00;
      @promotable(4) static<4> par {
        static<4> if  data_valid_reg.out {
          @promotable(4) static<4> seq  {
            @NODE_ID(5) invoke10;
            @NODE_ID(6) invoke20;
          }
        }
        @promotable static<1> if  stage2_valid.out {
          @NODE_ID(9) invoke30;
        }
      }
      @promotable static<1> par {
        @promotable static<1> if  data_valid_reg.out {
          @NODE_ID(13) invoke40;
        } else {
          @NODE_ID(14) invoke50;
        }
        @promotable static<1> if  stage2_valid.out {
          @NODE_ID(17) invoke60;
        } else {
          @NODE_ID(18) invoke70;
        }
      }
    }
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    static<1> group in_range0 {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group store_a0 {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
    }
    static<1> group no-op {
    }
    static<6> group invoke20 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    static<1> group invoke30 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    static<1> group no-op0 {
    }
    static<6> group invoke00 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    static<1> group invoke10 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    static<6> group invoke40 {
      mac.go = 1'd1;
      mac.c = mac.out;
    }
    static<1> group save_out0 {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
    }
  }
  control {
    seq {
      @promoted static<7> par {
        static<7> seq  {
          @promotable static<1> par {
            @NODE_ID(2) store_a0;
            @NODE_ID(3) store_b0;
          }
          @NODE_ID(4) invoke00;
        }
        static<2> seq  {
          no-op0;
          @NODE_ID(5) invoke10;
        }
      }
      in_range0;
      @NODE_ID(6) while comb_reg.out {
        static<8> seq  {
          @promotable(7) @promoted static<7> par {
            static<7> seq  {
              @promotable static<1> par {
                @NODE_ID(9) store_a0;
                @NODE_ID(10) store_b0;
              }
              @NODE_ID(11) invoke20;
            }
            static<2> seq  {
              no-op;
              @NODE_ID(12) invoke30;
            }
          }
          @promotable in_range0;
        }
      }
      static<7> seq  {
        @NODE_ID(13) invoke40;
        @NODE_ID(14) save_out0;
      }
    }
  }
}
Current pass: static-inline
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
  }
  wires {
    static<3> group invoke10 {
      mult_pipe.go = 1'd1;
      mult_pipe.right = b;
      mult_pipe.left = a;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.right = c;
      add.left = pipe1.out;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    static<6> group static_seq {
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      cond.in = %[1:5] ? data_valid_reg.out;
      cond_wire.in = %1 & %[1:5] ? data_valid_reg.out;
      cond.write_en = %1 & %[1:5] ? 1'd1;
      cond_wire.in = %[2:5] & %[1:5] ? cond.out;
      mult_pipe.go = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      mult_pipe.right = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? b;
      mult_pipe.left = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? a;
      pipe1.write_en = %4 & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      pipe1.in = %4 & %[1:5] & cond_wire.out & %[1:5] ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %1 & %[1:5] ? 1'd1;
      pipe2.in = stage2_valid.out & %1 & %[1:5] ? add.out;
      add.right = stage2_valid.out & %1 & %[1:5] ? c;
      add.left = stage2_valid.out & %1 & %[1:5] ? pipe1.out;
      stage2_valid.write_en = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      out_valid.write_en = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.write_en = !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
    }
    static<4> group static_seq0<"promotable"=4> {
      mult_pipe.go = %[0:3] ? 1'd1;
      mult_pipe.right = %[0:3] ? b;
      mult_pipe.left = %[0:3] ? a;
      pipe1.write_en = %3 ? 1'd1;
      pipe1.in = %3 ? mult_pipe.out;
    }
    static<4> group static_if {
      cond.in = data_valid_reg.out;
      cond_wire.in = %0 ? data_valid_reg.out;
      cond.write_en = %0 ? 1'd1;
      cond_wire.in = %[1:4] ? cond.out;
      mult_pipe.go = %[0:3] & %[0:4] & cond_wire.out ? 1'd1;
      mult_pipe.right = %[0:3] & %[0:4] & cond_wire.out ? b;
      mult_pipe.left = %[0:3] & %[0:4] & cond_wire.out ? a;
      pipe1.write_en = %3 & %[0:4] & cond_wire.out ? 1'd1;
      pipe1.in = %3 & %[0:4] & cond_wire.out ? mult_pipe.out;
    }
    static<1> group static_if0<"promotable"=1> {
      pipe2.write_en = stage2_valid.out ? 1'd1;
      pipe2.in = stage2_valid.out ? add.out;
      add.right = stage2_valid.out ? c;
      add.left = stage2_valid.out ? pipe1.out;
    }
    static<4> group static_par_thread<"promotable"=4> {
      cond.in = data_valid_reg.out;
      cond_wire.in = %0 ? data_valid_reg.out;
      cond.write_en = %0 ? 1'd1;
      cond_wire.in = %[1:4] ? cond.out;
      mult_pipe.go = %[0:3] & %[0:4] & cond_wire.out ? 1'd1;
      mult_pipe.right = %[0:3] & %[0:4] & cond_wire.out ? b;
      mult_pipe.left = %[0:3] & %[0:4] & cond_wire.out ? a;
      pipe1.write_en = %3 & %[0:4] & cond_wire.out ? 1'd1;
      pipe1.in = %3 & %[0:4] & cond_wire.out ? mult_pipe.out;
      pipe2.write_en = stage2_valid.out & %0 ? 1'd1;
      pipe2.in = stage2_valid.out & %0 ? add.out;
      add.right = stage2_valid.out & %0 ? c;
      add.left = stage2_valid.out & %0 ? pipe1.out;
    }
    static<1> group static_if1<"promotable"=1> {
      stage2_valid.write_en = data_valid_reg.out ? 1'd1;
      stage2_valid.in = data_valid_reg.out ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out ? 1'd1;
      stage2_valid.in = !data_valid_reg.out ? 1'd0;
    }
    static<1> group static_if2<"promotable"=1> {
      out_valid.write_en = stage2_valid.out ? 1'd1;
      out_valid.in = stage2_valid.out ? 1'd1;
      out_valid.write_en = !stage2_valid.out ? 1'd1;
      out_valid.in = !stage2_valid.out ? 1'd0;
    }
    static<1> group static_par_thread0<"promotable"=1> {
      stage2_valid.write_en = data_valid_reg.out ? 1'd1;
      stage2_valid.in = data_valid_reg.out ? 1'd1;
      stage2_valid.write_en = !data_valid_reg.out ? 1'd1;
      stage2_valid.in = !data_valid_reg.out ? 1'd0;
      out_valid.write_en = stage2_valid.out ? 1'd1;
      out_valid.in = stage2_valid.out ? 1'd1;
      out_valid.write_en = !stage2_valid.out ? 1'd1;
      out_valid.in = !stage2_valid.out ? 1'd0;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    static<1> group in_range0 {
      lt0.right = 4'd10;
      lt0.left = idx0.out;
      comb_reg.in = lt0.out;
      comb_reg.write_en = 1'd1;
    }
    static<1> group store_a0 {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
    }
    static<1> group no-op {
    }
    static<6> group invoke20 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
      mac.c = mac.out;
    }
    static<1> group invoke30 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    static<1> group no-op0 {
    }
    static<6> group invoke00 {
      mac.go = 1'd1;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.b = read_b.out;
    }
    static<1> group invoke10 {
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
      add0.right = idx0.out;
      add0.left = 4'd1;
    }
    static<6> group invoke40 {
      mac.go = 1'd1;
      mac.c = mac.out;
    }
    static<1> group save_out0 {
      out.write_data = mac.out;
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
    }
    static<7> group static_seq {
      read_a.write_en = %0 ? 1'd1;
      a.addr0 = %0 ? idx0.out;
      read_a.in = %0 ? a.read_data;
      read_b.write_en = %0 ? 1'd1;
      b.addr0 = %0 ? idx0.out;
      read_b.in = %0 ? b.read_data;
      mac.go = %[1:7] ? 1'd1;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.b = %[1:7] ? read_b.out;
    }
    static<1> group static_par_thread<"promotable"=1> {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
    }
    static<2> group static_seq0 {
      idx0.write_en = %1 ? 1'd1;
      idx0.in = %1 ? add0.out;
      add0.right = %1 ? idx0.out;
      add0.left = %1 ? 4'd1;
    }
    static<7> group static_par_thread0<"promoted"=1> {
      read_a.write_en = %0 ? 1'd1;
      a.addr0 = %0 ? idx0.out;
      read_a.in = %0 ? a.read_data;
      read_b.write_en = %0 ? 1'd1;
      b.addr0 = %0 ? idx0.out;
      read_b.in = %0 ? b.read_data;
      mac.go = %[1:7] ? 1'd1;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.b = %[1:7] ? read_b.out;
      idx0.write_en = %1 & %[0:2] ? 1'd1;
      idx0.in = %1 & %[0:2] ? add0.out;
      add0.right = %1 & %[0:2] ? idx0.out;
      add0.left = %1 & %[0:2] ? 4'd1;
    }
    static<8> group static_seq1 {
      read_a.write_en = %0 & %[0:7] ? 1'd1;
      a.addr0 = %0 & %[0:7] ? idx0.out;
      read_a.in = %0 & %[0:7] ? a.read_data;
      read_b.write_en = %0 & %[0:7] ? 1'd1;
      b.addr0 = %0 & %[0:7] ? idx0.out;
      read_b.in = %0 & %[0:7] ? b.read_data;
      mac.go = %[1:7] & %[0:7] ? 1'd1;
      mac.data_valid = %[1:7] & %[0:7] ? 1'd1;
      mac.a = %[1:7] & %[0:7] ? read_a.out;
      mac.b = %[1:7] & %[0:7] ? read_b.out;
      mac.c = %[1:7] & %[0:7] ? mac.out;
      idx0.write_en = %1 & %[0:2] & %[0:7] ? 1'd1;
      idx0.in = %1 & %[0:2] & %[0:7] ? add0.out;
      add0.right = %1 & %[0:2] & %[0:7] ? idx0.out;
      add0.left = %1 & %[0:2] & %[0:7] ? 4'd1;
      lt0.right = %7 ? 4'd10;
      lt0.left = %7 ? idx0.out;
      comb_reg.in = %7 ? lt0.out;
      comb_reg.write_en = %7 ? 1'd1;
    }
    static<7> group static_seq2 {
      read_a.write_en = %0 ? 1'd1;
      a.addr0 = %0 ? idx0.out;
      read_a.in = %0 ? a.read_data;
      read_b.write_en = %0 ? 1'd1;
      b.addr0 = %0 ? idx0.out;
      read_b.in = %0 ? b.read_data;
      mac.go = %[1:7] ? 1'd1;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.b = %[1:7] ? read_b.out;
      mac.c = %[1:7] ? mac.out;
    }
    static<1> group static_par_thread1<"promotable"=1> {
      read_a.write_en = 1'd1;
      a.addr0 = idx0.out;
      read_a.in = a.read_data;
      read_b.write_en = 1'd1;
      b.addr0 = idx0.out;
      read_b.in = b.read_data;
    }
    static<2> group static_seq3 {
      idx0.write_en = %1 ? 1'd1;
      idx0.in = %1 ? add0.out;
      add0.right = %1 ? idx0.out;
      add0.left = %1 ? 4'd1;
    }
    static<7> group static_par_thread2<"promotable"=7, "promoted"=1> {
      read_a.write_en = %0 ? 1'd1;
      a.addr0 = %0 ? idx0.out;
      read_a.in = %0 ? a.read_data;
      read_b.write_en = %0 ? 1'd1;
      b.addr0 = %0 ? idx0.out;
      read_b.in = %0 ? b.read_data;
      mac.go = %[1:7] ? 1'd1;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.b = %[1:7] ? read_b.out;
      mac.c = %[1:7] ? mac.out;
      idx0.write_en = %1 & %[0:2] ? 1'd1;
      idx0.in = %1 & %[0:2] ? add0.out;
      add0.right = %1 & %[0:2] ? idx0.out;
      add0.left = %1 & %[0:2] ? 4'd1;
    }
    static<7> group static_seq4 {
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
      out.write_data = %6 ? mac.out;
      out.write_en = %6 ? 1'd1;
      out.addr0 = %6 ? 1'd0;
    }
  }
  control {
    seq {
      static_par_thread0;
      in_range0;
      @NODE_ID(6) while comb_reg.out {
        static_seq1;
      }
      static_seq4;
    }
  }
}
Current pass: merge-assigns
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
  }
  wires {
    static<3> group invoke10 {
      mult_pipe.left = a;
      mult_pipe.go = 1'd1;
      mult_pipe.right = b;
    }
    static<1> group invoke20 {
      pipe1.write_en = 1'd1;
      pipe1.in = mult_pipe.out;
    }
    static<1> group invoke30 {
      pipe2.write_en = 1'd1;
      pipe2.in = add.out;
      add.left = pipe1.out;
      add.right = c;
    }
    static<1> group invoke40 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd1;
    }
    static<1> group invoke50 {
      stage2_valid.write_en = 1'd1;
      stage2_valid.in = 1'd0;
    }
    static<1> group invoke60 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd1;
    }
    static<1> group invoke70 {
      out_valid.write_en = 1'd1;
      out_valid.in = 1'd0;
    }
    static<1> group invoke00 {
      data_valid_reg.write_en = 1'd1;
      data_valid_reg.in = data_valid;
    }
    static<6> group static_seq {
      cond.write_en = %1 & %[1:5] ? 1'd1;
      cond.in = %[1:5] ? data_valid_reg.out;
      pipe2.write_en = stage2_valid.out & %1 & %[1:5] ? 1'd1;
      pipe2.in = stage2_valid.out & %1 & %[1:5] ? add.out;
      out_valid.write_en = stage2_valid.out & %5 | !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
      mult_pipe.left = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? a;
      mult_pipe.go = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      mult_pipe.right = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? b;
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      add.left = stage2_valid.out & %1 & %[1:5] ? pipe1.out;
      add.right = stage2_valid.out & %1 & %[1:5] ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 | !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      cond_wire.in = %[2:5] & %[1:5] ? cond.out;
      cond_wire.in = %1 & %[1:5] ? data_valid_reg.out;
      pipe1.write_en = %4 & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      pipe1.in = %4 & %[1:5] & cond_wire.out & %[1:5] ? mult_pipe.out;
    }
    static<4> group static_seq0<"promotable"=4> {
      mult_pipe.left = %[0:3] ? a;
      mult_pipe.go = %[0:3] ? 1'd1;
      mult_pipe.right = %[0:3] ? b;
      pipe1.write_en = %3 ? 1'd1;
      pipe1.in = %3 ? mult_pipe.out;
    }
    static<4> group static_if {
      cond.write_en = %0 ? 1'd1;
      cond.in = data_valid_reg.out;
      mult_pipe.left = %[0:3] & %[0:4] & cond_wire.out ? a;
      mult_pipe.go = %[0:3] & %[0:4] & cond_wire.out ? 1'd1;
      mult_pipe.right = %[0:3] & %[0:4] & cond_wire.out ? b;
      cond_wire.in = %[1:4] ? cond.out;
      cond_wire.in = %0 ? data_valid_reg.out;
      pipe1.write_en = %3 & %[0:4] & cond_wire.out ? 1'd1;
      pipe1.in = %3 & %[0:4] & cond_wire.out ? mult_pipe.out;
    }
    static<1> group static_if0<"promotable"=1> {
      pipe2.write_en = stage2_valid.out ? 1'd1;
      pipe2.in = stage2_valid.out ? add.out;
      add.left = stage2_valid.out ? pipe1.out;
      add.right = stage2_valid.out ? c;
    }
    static<4> group static_par_thread<"promotable"=4> {
      cond.write_en = %0 ? 1'd1;
      cond.in = data_valid_reg.out;
      pipe2.write_en = stage2_valid.out & %0 ? 1'd1;
      pipe2.in = stage2_valid.out & %0 ? add.out;
      mult_pipe.left = %[0:3] & %[0:4] & cond_wire.out ? a;
      mult_pipe.go = %[0:3] & %[0:4] & cond_wire.out ? 1'd1;
      mult_pipe.right = %[0:3] & %[0:4] & cond_wire.out ? b;
      add.left = stage2_valid.out & %0 ? pipe1.out;
      add.right = stage2_valid.out & %0 ? c;
      cond_wire.in = %[1:4] ? cond.out;
      cond_wire.in = %0 ? data_valid_reg.out;
      pipe1.write_en = %3 & %[0:4] & cond_wire.out ? 1'd1;
      pipe1.in = %3 & %[0:4] & cond_wire.out ? mult_pipe.out;
    }
    static<1> group static_if1<"promotable"=1> {
      stage2_valid.write_en = !data_valid_reg.out | data_valid_reg.out ? 1'd1;
      stage2_valid.in = data_valid_reg.out ? 1'd1;
      stage2_valid.in = !data_valid_reg.out ? 1'd0;
    }
    static<1> group static_if2<"promotable"=1> {
      out_valid.write_en = !stage2_valid.out | stage2_valid.out ? 1'd1;
      out_valid.in = stage2_valid.out ? 1'd1;
      out_valid.in = !stage2_valid.out ? 1'd0;
    }
    static<1> group static_par_thread0<"promotable"=1> {
      out_valid.write_en = !stage2_valid.out | stage2_valid.out ? 1'd1;
      out_valid.in = stage2_valid.out ? 1'd1;
      out_valid.in = !stage2_valid.out ? 1'd0;
      stage2_valid.write_en = !data_valid_reg.out | data_valid_reg.out ? 1'd1;
      stage2_valid.in = data_valid_reg.out ? 1'd1;
      stage2_valid.in = !data_valid_reg.out ? 1'd0;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    static<1> group in_range0 {
      comb_reg.write_en = 1'd1;
      comb_reg.in = lt0.out;
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    static<1> group store_a0 {
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<1> group store_b0 {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
    }
    static<1> group no-op {
    }
    static<6> group invoke20 {
      mac.b = read_b.out;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.go = 1'd1;
      mac.c = mac.out;
    }
    static<1> group invoke30 {
      add0.left = 4'd1;
      add0.right = idx0.out;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
    }
    static<1> group no-op0 {
    }
    static<6> group invoke00 {
      mac.b = read_b.out;
      mac.data_valid = 1'd1;
      mac.a = read_a.out;
      mac.go = 1'd1;
    }
    static<1> group invoke10 {
      add0.left = 4'd1;
      add0.right = idx0.out;
      idx0.write_en = 1'd1;
      idx0.in = add0.out;
    }
    static<6> group invoke40 {
      mac.go = 1'd1;
      mac.c = mac.out;
    }
    static<1> group save_out0 {
      out.write_en = 1'd1;
      out.addr0 = 1'd0;
      out.write_data = mac.out;
    }
    static<7> group static_seq {
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      mac.b = %[1:7] ? read_b.out;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.go = %[1:7] ? 1'd1;
    }
    static<1> group static_par_thread<"promotable"=1> {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<2> group static_seq0 {
      add0.left = %1 ? 4'd1;
      add0.right = %1 ? idx0.out;
      idx0.write_en = %1 ? 1'd1;
      idx0.in = %1 ? add0.out;
    }
    static<7> group static_par_thread0<"promoted"=1> {
      add0.left = %1 & %[0:2] ? 4'd1;
      add0.right = %1 & %[0:2] ? idx0.out;
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      idx0.write_en = %1 & %[0:2] ? 1'd1;
      idx0.in = %1 & %[0:2] ? add0.out;
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      mac.b = %[1:7] ? read_b.out;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.go = %[1:7] ? 1'd1;
    }
    static<8> group static_seq1 {
      add0.left = %1 & %[0:2] & %[0:7] ? 4'd1;
      add0.right = %1 & %[0:2] & %[0:7] ? idx0.out;
      b.addr0 = %0 & %[0:7] ? idx0.out;
      comb_reg.write_en = %7 ? 1'd1;
      comb_reg.in = %7 ? lt0.out;
      read_b.write_en = %0 & %[0:7] ? 1'd1;
      read_b.in = %0 & %[0:7] ? b.read_data;
      idx0.write_en = %1 & %[0:2] & %[0:7] ? 1'd1;
      idx0.in = %1 & %[0:2] & %[0:7] ? add0.out;
      a.addr0 = %0 & %[0:7] ? idx0.out;
      read_a.write_en = %0 & %[0:7] ? 1'd1;
      read_a.in = %0 & %[0:7] ? a.read_data;
      mac.b = %[1:7] & %[0:7] ? read_b.out;
      mac.data_valid = %[1:7] & %[0:7] ? 1'd1;
      mac.a = %[1:7] & %[0:7] ? read_a.out;
      mac.go = %[1:7] & %[0:7] ? 1'd1;
      mac.c = %[1:7] & %[0:7] ? mac.out;
      lt0.left = %7 ? idx0.out;
      lt0.right = %7 ? 4'd10;
    }
    static<7> group static_seq2 {
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      mac.b = %[1:7] ? read_b.out;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.go = %[1:7] ? 1'd1;
      mac.c = %[1:7] ? mac.out;
    }
    static<1> group static_par_thread1<"promotable"=1> {
      b.addr0 = idx0.out;
      read_b.write_en = 1'd1;
      read_b.in = b.read_data;
      a.addr0 = idx0.out;
      read_a.write_en = 1'd1;
      read_a.in = a.read_data;
    }
    static<2> group static_seq3 {
      add0.left = %1 ? 4'd1;
      add0.right = %1 ? idx0.out;
      idx0.write_en = %1 ? 1'd1;
      idx0.in = %1 ? add0.out;
    }
    static<7> group static_par_thread2<"promotable"=7, "promoted"=1> {
      add0.left = %1 & %[0:2] ? 4'd1;
      add0.right = %1 & %[0:2] ? idx0.out;
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      idx0.write_en = %1 & %[0:2] ? 1'd1;
      idx0.in = %1 & %[0:2] ? add0.out;
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      mac.b = %[1:7] ? read_b.out;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.go = %[1:7] ? 1'd1;
      mac.c = %[1:7] ? mac.out;
    }
    static<7> group static_seq4 {
      out.write_en = %6 ? 1'd1;
      out.addr0 = %6 ? 1'd0;
      out.write_data = %6 ? mac.out;
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
    }
  }
  control {
    seq {
      static_par_thread0;
      in_range0;
      @NODE_ID(6) while comb_reg.out {
        static_seq1;
      }
      static_seq4;
    }
  }
}
Current pass: dead-group-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      cond.write_en = %1 & %[1:5] ? 1'd1;
      cond.in = %[1:5] ? data_valid_reg.out;
      pipe2.write_en = stage2_valid.out & %1 & %[1:5] ? 1'd1;
      pipe2.in = stage2_valid.out & %1 & %[1:5] ? add.out;
      out_valid.write_en = stage2_valid.out & %5 | !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
      mult_pipe.left = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? a;
      mult_pipe.go = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      mult_pipe.right = %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? b;
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      add.left = stage2_valid.out & %1 & %[1:5] ? pipe1.out;
      add.right = stage2_valid.out & %1 & %[1:5] ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 | !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      cond_wire.in = %[2:5] & %[1:5] ? cond.out;
      cond_wire.in = %1 & %[1:5] ? data_valid_reg.out;
      pipe1.write_en = %4 & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      pipe1.in = %4 & %[1:5] & cond_wire.out & %[1:5] ? mult_pipe.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    static<1> group in_range0 {
      comb_reg.write_en = 1'd1;
      comb_reg.in = lt0.out;
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    static<7> group static_par_thread0<"promoted"=1> {
      add0.left = %1 & %[0:2] ? 4'd1;
      add0.right = %1 & %[0:2] ? idx0.out;
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      idx0.write_en = %1 & %[0:2] ? 1'd1;
      idx0.in = %1 & %[0:2] ? add0.out;
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      mac.b = %[1:7] ? read_b.out;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.go = %[1:7] ? 1'd1;
    }
    static<8> group static_seq1 {
      add0.left = %1 & %[0:2] & %[0:7] ? 4'd1;
      add0.right = %1 & %[0:2] & %[0:7] ? idx0.out;
      b.addr0 = %0 & %[0:7] ? idx0.out;
      comb_reg.write_en = %7 ? 1'd1;
      comb_reg.in = %7 ? lt0.out;
      read_b.write_en = %0 & %[0:7] ? 1'd1;
      read_b.in = %0 & %[0:7] ? b.read_data;
      idx0.write_en = %1 & %[0:2] & %[0:7] ? 1'd1;
      idx0.in = %1 & %[0:2] & %[0:7] ? add0.out;
      a.addr0 = %0 & %[0:7] ? idx0.out;
      read_a.write_en = %0 & %[0:7] ? 1'd1;
      read_a.in = %0 & %[0:7] ? a.read_data;
      mac.b = %[1:7] & %[0:7] ? read_b.out;
      mac.data_valid = %[1:7] & %[0:7] ? 1'd1;
      mac.a = %[1:7] & %[0:7] ? read_a.out;
      mac.go = %[1:7] & %[0:7] ? 1'd1;
      mac.c = %[1:7] & %[0:7] ? mac.out;
      lt0.left = %7 ? idx0.out;
      lt0.right = %7 ? 4'd10;
    }
    static<7> group static_seq4 {
      out.write_en = %6 ? 1'd1;
      out.addr0 = %6 ? 1'd0;
      out.write_data = %6 ? mac.out;
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
    }
  }
  control {
    seq {
      static_par_thread0;
      in_range0;
      @NODE_ID(6) while comb_reg.out {
        static_seq1;
      }
      static_seq4;
    }
  }
}
Current pass: add-guard
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      cond.write_en = %[0:6] & %1 & %[1:5] ? 1'd1;
      cond.in = %[0:6] & %[1:5] ? data_valid_reg.out;
      pipe2.write_en = %[0:6] & stage2_valid.out & %1 & %[1:5] ? 1'd1;
      pipe2.in = %[0:6] & stage2_valid.out & %1 & %[1:5] ? add.out;
      out_valid.write_en = %[0:6] & (stage2_valid.out & %5 | !stage2_valid.out & %5) ? 1'd1;
      out_valid.in = %[0:6] & stage2_valid.out & %5 ? 1'd1;
      out_valid.in = %[0:6] & !stage2_valid.out & %5 ? 1'd0;
      mult_pipe.left = %[0:6] & %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? a;
      mult_pipe.go = %[0:6] & %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      mult_pipe.right = %[0:6] & %[1:4] & %[1:5] & cond_wire.out & %[1:5] ? b;
      data_valid_reg.write_en = %[0:6] & %0 ? 1'd1;
      data_valid_reg.in = %[0:6] & %0 ? data_valid;
      add.left = %[0:6] & stage2_valid.out & %1 & %[1:5] ? pipe1.out;
      add.right = %[0:6] & stage2_valid.out & %1 & %[1:5] ? c;
      stage2_valid.write_en = %[0:6] & (data_valid_reg.out & %5 | !data_valid_reg.out & %5) ? 1'd1;
      stage2_valid.in = %[0:6] & data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = %[0:6] & !data_valid_reg.out & %5 ? 1'd0;
      cond_wire.in = %[0:6] & %[2:5] & %[1:5] ? cond.out;
      cond_wire.in = %[0:6] & %1 & %[1:5] ? data_valid_reg.out;
      pipe1.write_en = %[0:6] & %4 & %[1:5] & cond_wire.out & %[1:5] ? 1'd1;
      pipe1.in = %[0:6] & %4 & %[1:5] & cond_wire.out & %[1:5] ? mult_pipe.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    static<1> group in_range0 {
      comb_reg.write_en = 1'd1;
      comb_reg.in = lt0.out;
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    static<7> group static_par_thread0<"promoted"=1> {
      add0.left = %1 & %[0:2] ? 4'd1;
      add0.right = %1 & %[0:2] ? idx0.out;
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      idx0.write_en = %1 & %[0:2] ? 1'd1;
      idx0.in = %1 & %[0:2] ? add0.out;
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      mac.b = %[1:7] ? read_b.out;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.go = %[1:7] ? 1'd1;
    }
    static<8> group static_seq1 {
      add0.left = %1 & %[0:2] & %[0:7] ? 4'd1;
      add0.right = %1 & %[0:2] & %[0:7] ? idx0.out;
      b.addr0 = %0 & %[0:7] ? idx0.out;
      comb_reg.write_en = %7 ? 1'd1;
      comb_reg.in = %7 ? lt0.out;
      read_b.write_en = %0 & %[0:7] ? 1'd1;
      read_b.in = %0 & %[0:7] ? b.read_data;
      idx0.write_en = %1 & %[0:2] & %[0:7] ? 1'd1;
      idx0.in = %1 & %[0:2] & %[0:7] ? add0.out;
      a.addr0 = %0 & %[0:7] ? idx0.out;
      read_a.write_en = %0 & %[0:7] ? 1'd1;
      read_a.in = %0 & %[0:7] ? a.read_data;
      mac.b = %[1:7] & %[0:7] ? read_b.out;
      mac.data_valid = %[1:7] & %[0:7] ? 1'd1;
      mac.a = %[1:7] & %[0:7] ? read_a.out;
      mac.go = %[1:7] & %[0:7] ? 1'd1;
      mac.c = %[1:7] & %[0:7] ? mac.out;
      lt0.left = %7 ? idx0.out;
      lt0.right = %7 ? 4'd10;
    }
    static<7> group static_seq4 {
      out.write_en = %6 ? 1'd1;
      out.addr0 = %6 ? 1'd0;
      out.write_data = %6 ? mac.out;
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
    }
  }
  control {
    seq {
      static_par_thread0;
      in_range0;
      @NODE_ID(6) while comb_reg.out {
        static_seq1;
      }
      static_seq4;
    }
  }
}
Current pass: simplify-static-guards
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      cond.write_en = %1 ? 1'd1;
      cond.in = %[1:5] ? data_valid_reg.out;
      pipe2.write_en = stage2_valid.out & %1 ? 1'd1;
      pipe2.in = stage2_valid.out & %1 ? add.out;
      out_valid.write_en = stage2_valid.out & %5 | !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
      mult_pipe.left = cond_wire.out & %[1:4] ? a;
      mult_pipe.go = cond_wire.out & %[1:4] ? 1'd1;
      mult_pipe.right = cond_wire.out & %[1:4] ? b;
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      add.left = stage2_valid.out & %1 ? pipe1.out;
      add.right = stage2_valid.out & %1 ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 | !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      cond_wire.in = %[2:5] ? cond.out;
      cond_wire.in = %1 ? data_valid_reg.out;
      pipe1.write_en = cond_wire.out & %4 ? 1'd1;
      pipe1.in = cond_wire.out & %4 ? mult_pipe.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    static<1> group in_range0 {
      comb_reg.write_en = 1'd1;
      comb_reg.in = lt0.out;
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    static<7> group static_par_thread0<"promoted"=1> {
      add0.left = %1 ? 4'd1;
      add0.right = %1 ? idx0.out;
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      idx0.write_en = %1 ? 1'd1;
      idx0.in = %1 ? add0.out;
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      mac.b = %[1:7] ? read_b.out;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.go = %[1:7] ? 1'd1;
    }
    static<8> group static_seq1 {
      add0.left = %1 ? 4'd1;
      add0.right = %1 ? idx0.out;
      b.addr0 = %0 ? idx0.out;
      comb_reg.write_en = %7 ? 1'd1;
      comb_reg.in = %7 ? lt0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      idx0.write_en = %1 ? 1'd1;
      idx0.in = %1 ? add0.out;
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      mac.b = %[1:7] ? read_b.out;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.go = %[1:7] ? 1'd1;
      mac.c = %[1:7] ? mac.out;
      lt0.left = %7 ? idx0.out;
      lt0.right = %7 ? 4'd10;
    }
    static<7> group static_seq4 {
      out.write_en = %6 ? 1'd1;
      out.addr0 = %6 ? 1'd0;
      out.write_data = %6 ? mac.out;
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
    }
  }
  control {
    seq {
      static_par_thread0;
      in_range0;
      @NODE_ID(6) while comb_reg.out {
        static_seq1;
      }
      static_seq4;
    }
  }
}
Current pass: static-fsm-opts
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
  }
  wires {
    static<6> group static_seq {
      cond.write_en = %1 ? 1'd1;
      cond.in = %[1:5] ? data_valid_reg.out;
      pipe2.write_en = stage2_valid.out & %1 ? 1'd1;
      pipe2.in = stage2_valid.out & %1 ? add.out;
      out_valid.write_en = stage2_valid.out & %5 | !stage2_valid.out & %5 ? 1'd1;
      out_valid.in = stage2_valid.out & %5 ? 1'd1;
      out_valid.in = !stage2_valid.out & %5 ? 1'd0;
      mult_pipe.left = cond_wire.out & %[1:4] ? a;
      mult_pipe.go = cond_wire.out & %[1:4] ? 1'd1;
      mult_pipe.right = cond_wire.out & %[1:4] ? b;
      data_valid_reg.write_en = %0 ? 1'd1;
      data_valid_reg.in = %0 ? data_valid;
      add.left = stage2_valid.out & %1 ? pipe1.out;
      add.right = stage2_valid.out & %1 ? c;
      stage2_valid.write_en = data_valid_reg.out & %5 | !data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & %5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & %5 ? 1'd0;
      cond_wire.in = %[2:5] ? cond.out;
      cond_wire.in = %1 ? data_valid_reg.out;
      pipe1.write_en = cond_wire.out & %4 ? 1'd1;
      pipe1.in = cond_wire.out & %4 ? mult_pipe.out;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
  }
  control {
    static_seq;
  }
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
  }
  wires {
    static<1> group in_range0 {
      comb_reg.write_en = 1'd1;
      comb_reg.in = lt0.out;
      lt0.left = idx0.out;
      lt0.right = 4'd10;
    }
    static<7> group static_par_thread0<"promoted"=1> {
      add0.left = %1 ? 4'd1;
      add0.right = %1 ? idx0.out;
      b.addr0 = %0 ? idx0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      idx0.write_en = %1 ? 1'd1;
      idx0.in = %1 ? add0.out;
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      mac.b = %[1:7] ? read_b.out;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.go = %[1:7] ? 1'd1;
    }
    static<8> group static_seq1 {
      add0.left = %1 ? 4'd1;
      add0.right = %1 ? idx0.out;
      b.addr0 = %0 ? idx0.out;
      comb_reg.write_en = %7 ? 1'd1;
      comb_reg.in = %7 ? lt0.out;
      read_b.write_en = %0 ? 1'd1;
      read_b.in = %0 ? b.read_data;
      idx0.write_en = %1 ? 1'd1;
      idx0.in = %1 ? add0.out;
      a.addr0 = %0 ? idx0.out;
      read_a.write_en = %0 ? 1'd1;
      read_a.in = %0 ? a.read_data;
      mac.b = %[1:7] ? read_b.out;
      mac.data_valid = %[1:7] ? 1'd1;
      mac.a = %[1:7] ? read_a.out;
      mac.go = %[1:7] ? 1'd1;
      mac.c = %[1:7] ? mac.out;
      lt0.left = %7 ? idx0.out;
      lt0.right = %7 ? 4'd10;
    }
    static<7> group static_seq4 {
      out.write_en = %6 ? 1'd1;
      out.addr0 = %6 ? 1'd0;
      out.write_data = %6 ? mac.out;
      mac.go = %[0:6] ? 1'd1;
      mac.c = %[0:6] ? mac.out;
    }
  }
  control {
    seq {
      static_par_thread0;
      in_range0;
      @NODE_ID(6) while comb_reg.out {
        static_seq1;
      }
      static_seq4;
    }
  }
}
Current pass: compile-static
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated ud = undef(1);
    @generated sig_reg = std_reg(1);
  }
  wires {
    group early_reset_static_seq {
      cond.write_en = fsm.out == 3'd1 ? 1'd1;
      cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
      pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
      pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
      out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
      out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
      out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
      mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
      mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
      mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
      data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
      data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
      add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
      add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
      stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
      stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
      stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
      cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
      cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
      pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
      pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
      early_reset_static_seq[done] = ud.out;
      adder.left = fsm.out;
      adder.right = 3'd1;
      fsm.in = fsm.out == 3'd0 & go ? adder.out;
      fsm.write_en = fsm.out == 3'd0 & go ? 1'd1;
      fsm.in = fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
      fsm.write_en = fsm.out != 3'd0 & fsm.out != 3'd5 ? 1'd1;
      fsm.in = fsm.out == 3'd5 ? 3'd0;
      fsm.write_en = fsm.out == 3'd5 ? 1'd1;
    }
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    adder.left = fsm.out;
    adder.right = 3'd1;
    fsm.in = fsm.out == 3'd0 & go ? adder.out;
    fsm.write_en = fsm.out == 3'd0 & go ? 1'd1;
    fsm.in = fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.write_en = fsm.out != 3'd0 & fsm.out != 3'd5 ? 1'd1;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    fsm.write_en = fsm.out == 3'd5 ? 1'd1;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
  }
  wires {
    group early_reset_static_par_thread0<"promoted"=1> {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      early_reset_static_par_thread0[done] = ud.out;
      adder.left = fsm.out;
      adder.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group early_reset_in_range0 {
      comb_reg.write_en = 1'd1;
      comb_reg.in = lt0.out;
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      early_reset_in_range0[done] = ud0.out;
    }
    group early_reset_static_seq1 {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      comb_reg.write_en = fsm.out == 4'd7 ? 1'd1;
      comb_reg.in = fsm.out == 4'd7 ? lt0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 ? mac.out;
      lt0.left = fsm.out == 4'd7 ? idx0.out;
      lt0.right = fsm.out == 4'd7 ? 4'd10;
      early_reset_static_seq1[done] = ud1.out;
      adder0.left = fsm.out;
      adder0.right = 4'd1;
      fsm.in = fsm.out != 4'd7 ? adder0.out;
      fsm.write_en = fsm.out != 4'd7 ? 1'd1;
      fsm.in = fsm.out == 4'd7 ? 4'd0;
      fsm.write_en = fsm.out == 4'd7 ? 1'd1;
    }
    group early_reset_static_seq4 {
      out.write_en = fsm.out == 4'd6 ? 1'd1;
      out.addr0 = fsm.out == 4'd6 ? 1'd0;
      out.write_data = fsm.out == 4'd6 ? mac.out;
      mac.go = fsm.out < 4'd6 ? 1'd1;
      mac.c = fsm.out < 4'd6 ? mac.out;
      early_reset_static_seq4[done] = ud2.out;
      adder1.left = fsm.out;
      adder1.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder1.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group wrapper_early_reset_static_par_thread0<"promoted"=1> {
      early_reset_static_par_thread0[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_par_thread0[done] = signal_reg.out ? 1'd1;
    }
    group wrapper_early_reset_in_range0 {
      early_reset_in_range0[go] = 1'd1;
      signal_reg.write_en = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_in_range0[done] = signal_reg.out ? 1'd1;
    }
    group while_wrapper_early_reset_static_seq1 {
      early_reset_static_seq1[go] = 1'd1;
      while_wrapper_early_reset_static_seq1[done] = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
    }
    group wrapper_early_reset_static_seq4 {
      early_reset_static_seq4[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_seq4[done] = signal_reg.out ? 1'd1;
    }
    signal_reg.write_en = signal_reg.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
  }
  control {
    seq {
      wrapper_early_reset_static_par_thread0;
      wrapper_early_reset_in_range0;
      while_wrapper_early_reset_static_seq1;
      wrapper_early_reset_static_seq4;
    }
  }
}
Current pass: dead-group-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated ud = undef(1);
    @generated sig_reg = std_reg(1);
  }
  wires {
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    adder.left = fsm.out;
    adder.right = 3'd1;
    fsm.in = fsm.out == 3'd0 & go ? adder.out;
    fsm.write_en = fsm.out == 3'd0 & go ? 1'd1;
    fsm.in = fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.write_en = fsm.out != 3'd0 & fsm.out != 3'd5 ? 1'd1;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    fsm.write_en = fsm.out == 3'd5 ? 1'd1;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
  }
  wires {
    group early_reset_static_par_thread0<"promoted"=1> {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      early_reset_static_par_thread0[done] = ud.out;
      adder.left = fsm.out;
      adder.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group early_reset_in_range0 {
      comb_reg.write_en = 1'd1;
      comb_reg.in = lt0.out;
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      early_reset_in_range0[done] = ud0.out;
    }
    group early_reset_static_seq1 {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      comb_reg.write_en = fsm.out == 4'd7 ? 1'd1;
      comb_reg.in = fsm.out == 4'd7 ? lt0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 ? mac.out;
      lt0.left = fsm.out == 4'd7 ? idx0.out;
      lt0.right = fsm.out == 4'd7 ? 4'd10;
      early_reset_static_seq1[done] = ud1.out;
      adder0.left = fsm.out;
      adder0.right = 4'd1;
      fsm.in = fsm.out != 4'd7 ? adder0.out;
      fsm.write_en = fsm.out != 4'd7 ? 1'd1;
      fsm.in = fsm.out == 4'd7 ? 4'd0;
      fsm.write_en = fsm.out == 4'd7 ? 1'd1;
    }
    group early_reset_static_seq4 {
      out.write_en = fsm.out == 4'd6 ? 1'd1;
      out.addr0 = fsm.out == 4'd6 ? 1'd0;
      out.write_data = fsm.out == 4'd6 ? mac.out;
      mac.go = fsm.out < 4'd6 ? 1'd1;
      mac.c = fsm.out < 4'd6 ? mac.out;
      early_reset_static_seq4[done] = ud2.out;
      adder1.left = fsm.out;
      adder1.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder1.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group wrapper_early_reset_static_par_thread0<"promoted"=1> {
      early_reset_static_par_thread0[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_par_thread0[done] = signal_reg.out ? 1'd1;
    }
    group wrapper_early_reset_in_range0 {
      early_reset_in_range0[go] = 1'd1;
      signal_reg.write_en = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_in_range0[done] = signal_reg.out ? 1'd1;
    }
    group while_wrapper_early_reset_static_seq1 {
      early_reset_static_seq1[go] = 1'd1;
      while_wrapper_early_reset_static_seq1[done] = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
    }
    group wrapper_early_reset_static_seq4 {
      early_reset_static_seq4[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_seq4[done] = signal_reg.out ? 1'd1;
    }
    signal_reg.write_en = signal_reg.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
  }
  control {
    seq {
      wrapper_early_reset_static_par_thread0;
      wrapper_early_reset_in_range0;
      while_wrapper_early_reset_static_seq1;
      wrapper_early_reset_static_seq4;
    }
  }
}
Current pass: tdcc
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated ud = undef(1);
    @generated sig_reg = std_reg(1);
  }
  wires {
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    adder.left = fsm.out;
    adder.right = 3'd1;
    fsm.in = fsm.out == 3'd0 & go ? adder.out;
    fsm.write_en = fsm.out == 3'd0 & go ? 1'd1;
    fsm.in = fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.write_en = fsm.out != 3'd0 & fsm.out != 3'd5 ? 1'd1;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    fsm.write_en = fsm.out == 3'd5 ? 1'd1;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
    @generated fsm0 = std_reg(3);
  }
  wires {
    group early_reset_static_par_thread0<"promoted"=1> {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      early_reset_static_par_thread0[done] = ud.out;
      adder.left = fsm.out;
      adder.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group early_reset_in_range0 {
      comb_reg.write_en = 1'd1;
      comb_reg.in = lt0.out;
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      early_reset_in_range0[done] = ud0.out;
    }
    group early_reset_static_seq1 {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      comb_reg.write_en = fsm.out == 4'd7 ? 1'd1;
      comb_reg.in = fsm.out == 4'd7 ? lt0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 ? mac.out;
      lt0.left = fsm.out == 4'd7 ? idx0.out;
      lt0.right = fsm.out == 4'd7 ? 4'd10;
      early_reset_static_seq1[done] = ud1.out;
      adder0.left = fsm.out;
      adder0.right = 4'd1;
      fsm.in = fsm.out != 4'd7 ? adder0.out;
      fsm.write_en = fsm.out != 4'd7 ? 1'd1;
      fsm.in = fsm.out == 4'd7 ? 4'd0;
      fsm.write_en = fsm.out == 4'd7 ? 1'd1;
    }
    group early_reset_static_seq4 {
      out.write_en = fsm.out == 4'd6 ? 1'd1;
      out.addr0 = fsm.out == 4'd6 ? 1'd0;
      out.write_data = fsm.out == 4'd6 ? mac.out;
      mac.go = fsm.out < 4'd6 ? 1'd1;
      mac.c = fsm.out < 4'd6 ? mac.out;
      early_reset_static_seq4[done] = ud2.out;
      adder1.left = fsm.out;
      adder1.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder1.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group wrapper_early_reset_static_par_thread0<"promoted"=1> {
      early_reset_static_par_thread0[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_par_thread0[done] = signal_reg.out ? 1'd1;
    }
    group wrapper_early_reset_in_range0 {
      early_reset_in_range0[go] = 1'd1;
      signal_reg.write_en = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_in_range0[done] = signal_reg.out ? 1'd1;
    }
    group while_wrapper_early_reset_static_seq1 {
      early_reset_static_seq1[go] = 1'd1;
      while_wrapper_early_reset_static_seq1[done] = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
    }
    group wrapper_early_reset_static_seq4 {
      early_reset_static_seq4[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_seq4[done] = signal_reg.out ? 1'd1;
    }
    group tdcc {
      wrapper_early_reset_static_par_thread0[go] = !wrapper_early_reset_static_par_thread0[done] & fsm0.out == 3'd0 ? 1'd1;
      wrapper_early_reset_in_range0[go] = !wrapper_early_reset_in_range0[done] & fsm0.out == 3'd1 ? 1'd1;
      while_wrapper_early_reset_static_seq1[go] = !while_wrapper_early_reset_static_seq1[done] & fsm0.out == 3'd2 ? 1'd1;
      wrapper_early_reset_static_seq4[go] = !wrapper_early_reset_static_seq4[done] & fsm0.out == 3'd3 ? 1'd1;
      fsm0.in = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] ? 3'd1;
      fsm0.write_en = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] ? 3'd2;
      fsm0.write_en = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] ? 3'd3;
      fsm0.write_en = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] ? 3'd4;
      fsm0.write_en = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] ? 1'd1;
      tdcc[done] = fsm0.out == 3'd4 ? 1'd1;
    }
    signal_reg.write_en = signal_reg.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
    fsm0.in = fsm0.out == 3'd4 ? 3'd0;
    fsm0.write_en = fsm0.out == 3'd4 ? 1'd1;
  }
  control {
    tdcc;
  }
}
Current pass: dead-group-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated ud = undef(1);
    @generated sig_reg = std_reg(1);
  }
  wires {
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    adder.left = fsm.out;
    adder.right = 3'd1;
    fsm.in = fsm.out == 3'd0 & go ? adder.out;
    fsm.write_en = fsm.out == 3'd0 & go ? 1'd1;
    fsm.in = fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.write_en = fsm.out != 3'd0 & fsm.out != 3'd5 ? 1'd1;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    fsm.write_en = fsm.out == 3'd5 ? 1'd1;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
    @generated fsm0 = std_reg(3);
  }
  wires {
    group early_reset_static_par_thread0<"promoted"=1> {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      early_reset_static_par_thread0[done] = ud.out;
      adder.left = fsm.out;
      adder.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group early_reset_in_range0 {
      comb_reg.write_en = 1'd1;
      comb_reg.in = lt0.out;
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      early_reset_in_range0[done] = ud0.out;
    }
    group early_reset_static_seq1 {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      comb_reg.write_en = fsm.out == 4'd7 ? 1'd1;
      comb_reg.in = fsm.out == 4'd7 ? lt0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 ? mac.out;
      lt0.left = fsm.out == 4'd7 ? idx0.out;
      lt0.right = fsm.out == 4'd7 ? 4'd10;
      early_reset_static_seq1[done] = ud1.out;
      adder0.left = fsm.out;
      adder0.right = 4'd1;
      fsm.in = fsm.out != 4'd7 ? adder0.out;
      fsm.write_en = fsm.out != 4'd7 ? 1'd1;
      fsm.in = fsm.out == 4'd7 ? 4'd0;
      fsm.write_en = fsm.out == 4'd7 ? 1'd1;
    }
    group early_reset_static_seq4 {
      out.write_en = fsm.out == 4'd6 ? 1'd1;
      out.addr0 = fsm.out == 4'd6 ? 1'd0;
      out.write_data = fsm.out == 4'd6 ? mac.out;
      mac.go = fsm.out < 4'd6 ? 1'd1;
      mac.c = fsm.out < 4'd6 ? mac.out;
      early_reset_static_seq4[done] = ud2.out;
      adder1.left = fsm.out;
      adder1.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder1.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group wrapper_early_reset_static_par_thread0<"promoted"=1> {
      early_reset_static_par_thread0[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_par_thread0[done] = signal_reg.out ? 1'd1;
    }
    group wrapper_early_reset_in_range0 {
      early_reset_in_range0[go] = 1'd1;
      signal_reg.write_en = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_in_range0[done] = signal_reg.out ? 1'd1;
    }
    group while_wrapper_early_reset_static_seq1 {
      early_reset_static_seq1[go] = 1'd1;
      while_wrapper_early_reset_static_seq1[done] = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
    }
    group wrapper_early_reset_static_seq4 {
      early_reset_static_seq4[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_seq4[done] = signal_reg.out ? 1'd1;
    }
    group tdcc {
      wrapper_early_reset_static_par_thread0[go] = !wrapper_early_reset_static_par_thread0[done] & fsm0.out == 3'd0 ? 1'd1;
      wrapper_early_reset_in_range0[go] = !wrapper_early_reset_in_range0[done] & fsm0.out == 3'd1 ? 1'd1;
      while_wrapper_early_reset_static_seq1[go] = !while_wrapper_early_reset_static_seq1[done] & fsm0.out == 3'd2 ? 1'd1;
      wrapper_early_reset_static_seq4[go] = !wrapper_early_reset_static_seq4[done] & fsm0.out == 3'd3 ? 1'd1;
      fsm0.in = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] ? 3'd1;
      fsm0.write_en = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] ? 3'd2;
      fsm0.write_en = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] ? 3'd3;
      fsm0.write_en = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] ? 3'd4;
      fsm0.write_en = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] ? 1'd1;
      tdcc[done] = fsm0.out == 3'd4 ? 1'd1;
    }
    signal_reg.write_en = signal_reg.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
    fsm0.in = fsm0.out == 3'd4 ? 3'd0;
    fsm0.write_en = fsm0.out == 3'd4 ? 1'd1;
  }
  control {
    tdcc;
  }
}
Current pass: comb-prop
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated ud = undef(1);
    @generated sig_reg = std_reg(1);
  }
  wires {
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    adder.left = fsm.out;
    adder.right = 3'd1;
    fsm.in = fsm.out == 3'd0 & go ? adder.out;
    fsm.write_en = fsm.out == 3'd0 & go ? 1'd1;
    fsm.in = fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.write_en = fsm.out != 3'd0 & fsm.out != 3'd5 ? 1'd1;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    fsm.write_en = fsm.out == 3'd5 ? 1'd1;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
    @generated fsm0 = std_reg(3);
  }
  wires {
    group early_reset_static_par_thread0<"promoted"=1> {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      early_reset_static_par_thread0[done] = ud.out;
      adder.left = fsm.out;
      adder.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group early_reset_in_range0 {
      comb_reg.write_en = 1'd1;
      comb_reg.in = lt0.out;
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      early_reset_in_range0[done] = ud0.out;
    }
    group early_reset_static_seq1 {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      comb_reg.write_en = fsm.out == 4'd7 ? 1'd1;
      comb_reg.in = fsm.out == 4'd7 ? lt0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 ? mac.out;
      lt0.left = fsm.out == 4'd7 ? idx0.out;
      lt0.right = fsm.out == 4'd7 ? 4'd10;
      early_reset_static_seq1[done] = ud1.out;
      adder0.left = fsm.out;
      adder0.right = 4'd1;
      fsm.in = fsm.out != 4'd7 ? adder0.out;
      fsm.write_en = fsm.out != 4'd7 ? 1'd1;
      fsm.in = fsm.out == 4'd7 ? 4'd0;
      fsm.write_en = fsm.out == 4'd7 ? 1'd1;
    }
    group early_reset_static_seq4 {
      out.write_en = fsm.out == 4'd6 ? 1'd1;
      out.addr0 = fsm.out == 4'd6 ? 1'd0;
      out.write_data = fsm.out == 4'd6 ? mac.out;
      mac.go = fsm.out < 4'd6 ? 1'd1;
      mac.c = fsm.out < 4'd6 ? mac.out;
      early_reset_static_seq4[done] = ud2.out;
      adder1.left = fsm.out;
      adder1.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder1.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group wrapper_early_reset_static_par_thread0<"promoted"=1> {
      early_reset_static_par_thread0[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_par_thread0[done] = signal_reg.out ? 1'd1;
    }
    group wrapper_early_reset_in_range0 {
      early_reset_in_range0[go] = 1'd1;
      signal_reg.write_en = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_in_range0[done] = signal_reg.out ? 1'd1;
    }
    group while_wrapper_early_reset_static_seq1 {
      early_reset_static_seq1[go] = 1'd1;
      while_wrapper_early_reset_static_seq1[done] = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
    }
    group wrapper_early_reset_static_seq4 {
      early_reset_static_seq4[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_seq4[done] = signal_reg.out ? 1'd1;
    }
    group tdcc {
      wrapper_early_reset_static_par_thread0[go] = !wrapper_early_reset_static_par_thread0[done] & fsm0.out == 3'd0 ? 1'd1;
      wrapper_early_reset_in_range0[go] = !wrapper_early_reset_in_range0[done] & fsm0.out == 3'd1 ? 1'd1;
      while_wrapper_early_reset_static_seq1[go] = !while_wrapper_early_reset_static_seq1[done] & fsm0.out == 3'd2 ? 1'd1;
      wrapper_early_reset_static_seq4[go] = !wrapper_early_reset_static_seq4[done] & fsm0.out == 3'd3 ? 1'd1;
      fsm0.in = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] ? 3'd1;
      fsm0.write_en = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] ? 3'd2;
      fsm0.write_en = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] ? 3'd3;
      fsm0.write_en = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] ? 3'd4;
      fsm0.write_en = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] ? 1'd1;
      tdcc[done] = fsm0.out == 3'd4 ? 1'd1;
    }
    signal_reg.write_en = signal_reg.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
    fsm0.in = fsm0.out == 3'd4 ? 3'd0;
    fsm0.write_en = fsm0.out == 3'd4 ? 1'd1;
  }
  control {
    tdcc;
  }
}
Current pass: dead-assign-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated comb_reg = std_reg(32);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated ud = undef(1);
    @generated sig_reg = std_reg(1);
  }
  wires {
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    adder.left = fsm.out;
    adder.right = 3'd1;
    fsm.in = fsm.out == 3'd0 & go ? adder.out;
    fsm.write_en = fsm.out == 3'd0 & go ? 1'd1;
    fsm.in = fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.write_en = fsm.out != 3'd0 & fsm.out != 3'd5 ? 1'd1;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    fsm.write_en = fsm.out == 3'd5 ? 1'd1;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated comb_reg0 = std_reg(4);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
    @generated fsm0 = std_reg(3);
  }
  wires {
    group early_reset_static_par_thread0<"promoted"=1> {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      early_reset_static_par_thread0[done] = ud.out;
      adder.left = fsm.out;
      adder.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group early_reset_in_range0 {
      comb_reg.write_en = 1'd1;
      comb_reg.in = lt0.out;
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      early_reset_in_range0[done] = ud0.out;
    }
    group early_reset_static_seq1 {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      comb_reg.write_en = fsm.out == 4'd7 ? 1'd1;
      comb_reg.in = fsm.out == 4'd7 ? lt0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 ? mac.out;
      lt0.left = fsm.out == 4'd7 ? idx0.out;
      lt0.right = fsm.out == 4'd7 ? 4'd10;
      early_reset_static_seq1[done] = ud1.out;
      adder0.left = fsm.out;
      adder0.right = 4'd1;
      fsm.in = fsm.out != 4'd7 ? adder0.out;
      fsm.write_en = fsm.out != 4'd7 ? 1'd1;
      fsm.in = fsm.out == 4'd7 ? 4'd0;
      fsm.write_en = fsm.out == 4'd7 ? 1'd1;
    }
    group early_reset_static_seq4 {
      out.write_en = fsm.out == 4'd6 ? 1'd1;
      out.addr0 = fsm.out == 4'd6 ? 1'd0;
      out.write_data = fsm.out == 4'd6 ? mac.out;
      mac.go = fsm.out < 4'd6 ? 1'd1;
      mac.c = fsm.out < 4'd6 ? mac.out;
      early_reset_static_seq4[done] = ud2.out;
      adder1.left = fsm.out;
      adder1.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder1.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group wrapper_early_reset_static_par_thread0<"promoted"=1> {
      early_reset_static_par_thread0[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_par_thread0[done] = signal_reg.out ? 1'd1;
    }
    group wrapper_early_reset_in_range0 {
      early_reset_in_range0[go] = 1'd1;
      signal_reg.write_en = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_in_range0[done] = signal_reg.out ? 1'd1;
    }
    group while_wrapper_early_reset_static_seq1 {
      early_reset_static_seq1[go] = 1'd1;
      while_wrapper_early_reset_static_seq1[done] = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
    }
    group wrapper_early_reset_static_seq4 {
      early_reset_static_seq4[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_seq4[done] = signal_reg.out ? 1'd1;
    }
    group tdcc {
      wrapper_early_reset_static_par_thread0[go] = !wrapper_early_reset_static_par_thread0[done] & fsm0.out == 3'd0 ? 1'd1;
      wrapper_early_reset_in_range0[go] = !wrapper_early_reset_in_range0[done] & fsm0.out == 3'd1 ? 1'd1;
      while_wrapper_early_reset_static_seq1[go] = !while_wrapper_early_reset_static_seq1[done] & fsm0.out == 3'd2 ? 1'd1;
      wrapper_early_reset_static_seq4[go] = !wrapper_early_reset_static_seq4[done] & fsm0.out == 3'd3 ? 1'd1;
      fsm0.in = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] ? 3'd1;
      fsm0.write_en = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] ? 3'd2;
      fsm0.write_en = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] ? 3'd3;
      fsm0.write_en = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] ? 3'd4;
      fsm0.write_en = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] ? 1'd1;
      tdcc[done] = fsm0.out == 3'd4 ? 1'd1;
    }
    signal_reg.write_en = signal_reg.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
    fsm0.in = fsm0.out == 3'd4 ? 3'd0;
    fsm0.write_en = fsm0.out == 3'd4 ? 1'd1;
  }
  control {
    tdcc;
  }
}
Current pass: dead-cell-removal
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated sig_reg = std_reg(1);
  }
  wires {
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    adder.left = fsm.out;
    adder.right = 3'd1;
    fsm.in = fsm.out == 3'd0 & go ? adder.out;
    fsm.write_en = fsm.out == 3'd0 & go ? 1'd1;
    fsm.in = fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.write_en = fsm.out != 3'd0 & fsm.out != 3'd5 ? 1'd1;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    fsm.write_en = fsm.out == 3'd5 ? 1'd1;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
    @generated fsm0 = std_reg(3);
  }
  wires {
    group early_reset_static_par_thread0<"promoted"=1> {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      early_reset_static_par_thread0[done] = ud.out;
      adder.left = fsm.out;
      adder.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group early_reset_in_range0 {
      comb_reg.write_en = 1'd1;
      comb_reg.in = lt0.out;
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      early_reset_in_range0[done] = ud0.out;
    }
    group early_reset_static_seq1 {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      comb_reg.write_en = fsm.out == 4'd7 ? 1'd1;
      comb_reg.in = fsm.out == 4'd7 ? lt0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 ? mac.out;
      lt0.left = fsm.out == 4'd7 ? idx0.out;
      lt0.right = fsm.out == 4'd7 ? 4'd10;
      early_reset_static_seq1[done] = ud1.out;
      adder0.left = fsm.out;
      adder0.right = 4'd1;
      fsm.in = fsm.out != 4'd7 ? adder0.out;
      fsm.write_en = fsm.out != 4'd7 ? 1'd1;
      fsm.in = fsm.out == 4'd7 ? 4'd0;
      fsm.write_en = fsm.out == 4'd7 ? 1'd1;
    }
    group early_reset_static_seq4 {
      out.write_en = fsm.out == 4'd6 ? 1'd1;
      out.addr0 = fsm.out == 4'd6 ? 1'd0;
      out.write_data = fsm.out == 4'd6 ? mac.out;
      mac.go = fsm.out < 4'd6 ? 1'd1;
      mac.c = fsm.out < 4'd6 ? mac.out;
      early_reset_static_seq4[done] = ud2.out;
      adder1.left = fsm.out;
      adder1.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder1.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group wrapper_early_reset_static_par_thread0<"promoted"=1> {
      early_reset_static_par_thread0[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_par_thread0[done] = signal_reg.out ? 1'd1;
    }
    group wrapper_early_reset_in_range0 {
      early_reset_in_range0[go] = 1'd1;
      signal_reg.write_en = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_in_range0[done] = signal_reg.out ? 1'd1;
    }
    group while_wrapper_early_reset_static_seq1 {
      early_reset_static_seq1[go] = 1'd1;
      while_wrapper_early_reset_static_seq1[done] = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
    }
    group wrapper_early_reset_static_seq4 {
      early_reset_static_seq4[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_seq4[done] = signal_reg.out ? 1'd1;
    }
    group tdcc {
      wrapper_early_reset_static_par_thread0[go] = !wrapper_early_reset_static_par_thread0[done] & fsm0.out == 3'd0 ? 1'd1;
      wrapper_early_reset_in_range0[go] = !wrapper_early_reset_in_range0[done] & fsm0.out == 3'd1 ? 1'd1;
      while_wrapper_early_reset_static_seq1[go] = !while_wrapper_early_reset_static_seq1[done] & fsm0.out == 3'd2 ? 1'd1;
      wrapper_early_reset_static_seq4[go] = !wrapper_early_reset_static_seq4[done] & fsm0.out == 3'd3 ? 1'd1;
      fsm0.in = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] ? 3'd1;
      fsm0.write_en = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] ? 3'd2;
      fsm0.write_en = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] ? 3'd3;
      fsm0.write_en = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] ? 3'd4;
      fsm0.write_en = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] ? 1'd1;
      tdcc[done] = fsm0.out == 3'd4 ? 1'd1;
    }
    signal_reg.write_en = signal_reg.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
    fsm0.in = fsm0.out == 3'd4 ? 3'd0;
    fsm0.write_en = fsm0.out == 3'd4 ? 1'd1;
  }
  control {
    tdcc;
  }
}
Current pass: wrap-main
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated sig_reg = std_reg(1);
  }
  wires {
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    adder.left = fsm.out;
    adder.right = 3'd1;
    fsm.in = fsm.out == 3'd0 & go ? adder.out;
    fsm.write_en = fsm.out == 3'd0 & go ? 1'd1;
    fsm.in = fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.write_en = fsm.out != 3'd0 & fsm.out != 3'd5 ? 1'd1;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    fsm.write_en = fsm.out == 3'd5 ? 1'd1;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
    @generated fsm0 = std_reg(3);
  }
  wires {
    group early_reset_static_par_thread0<"promoted"=1> {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      early_reset_static_par_thread0[done] = ud.out;
      adder.left = fsm.out;
      adder.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group early_reset_in_range0 {
      comb_reg.write_en = 1'd1;
      comb_reg.in = lt0.out;
      lt0.left = idx0.out;
      lt0.right = 4'd10;
      early_reset_in_range0[done] = ud0.out;
    }
    group early_reset_static_seq1 {
      add0.left = fsm.out == 4'd1 ? 4'd1;
      add0.right = fsm.out == 4'd1 ? idx0.out;
      b.addr0 = fsm.out == 4'd0 ? idx0.out;
      comb_reg.write_en = fsm.out == 4'd7 ? 1'd1;
      comb_reg.in = fsm.out == 4'd7 ? lt0.out;
      read_b.write_en = fsm.out == 4'd0 ? 1'd1;
      read_b.in = fsm.out == 4'd0 ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 ? 1'd1;
      idx0.in = fsm.out == 4'd1 ? add0.out;
      a.addr0 = fsm.out == 4'd0 ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 ? 1'd1;
      read_a.in = fsm.out == 4'd0 ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 ? 1'd1;
      mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 ? mac.out;
      lt0.left = fsm.out == 4'd7 ? idx0.out;
      lt0.right = fsm.out == 4'd7 ? 4'd10;
      early_reset_static_seq1[done] = ud1.out;
      adder0.left = fsm.out;
      adder0.right = 4'd1;
      fsm.in = fsm.out != 4'd7 ? adder0.out;
      fsm.write_en = fsm.out != 4'd7 ? 1'd1;
      fsm.in = fsm.out == 4'd7 ? 4'd0;
      fsm.write_en = fsm.out == 4'd7 ? 1'd1;
    }
    group early_reset_static_seq4 {
      out.write_en = fsm.out == 4'd6 ? 1'd1;
      out.addr0 = fsm.out == 4'd6 ? 1'd0;
      out.write_data = fsm.out == 4'd6 ? mac.out;
      mac.go = fsm.out < 4'd6 ? 1'd1;
      mac.c = fsm.out < 4'd6 ? mac.out;
      early_reset_static_seq4[done] = ud2.out;
      adder1.left = fsm.out;
      adder1.right = 4'd1;
      fsm.in = fsm.out != 4'd6 ? adder1.out;
      fsm.write_en = fsm.out != 4'd6 ? 1'd1;
      fsm.in = fsm.out == 4'd6 ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 ? 1'd1;
    }
    group wrapper_early_reset_static_par_thread0<"promoted"=1> {
      early_reset_static_par_thread0[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_par_thread0[done] = signal_reg.out ? 1'd1;
    }
    group wrapper_early_reset_in_range0 {
      early_reset_in_range0[go] = 1'd1;
      signal_reg.write_en = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = 1'b1 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_in_range0[done] = signal_reg.out ? 1'd1;
    }
    group while_wrapper_early_reset_static_seq1 {
      early_reset_static_seq1[go] = 1'd1;
      while_wrapper_early_reset_static_seq1[done] = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
    }
    group wrapper_early_reset_static_seq4 {
      early_reset_static_seq4[go] = 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out ? 1'd1;
      wrapper_early_reset_static_seq4[done] = signal_reg.out ? 1'd1;
    }
    group tdcc {
      wrapper_early_reset_static_par_thread0[go] = !wrapper_early_reset_static_par_thread0[done] & fsm0.out == 3'd0 ? 1'd1;
      wrapper_early_reset_in_range0[go] = !wrapper_early_reset_in_range0[done] & fsm0.out == 3'd1 ? 1'd1;
      while_wrapper_early_reset_static_seq1[go] = !while_wrapper_early_reset_static_seq1[done] & fsm0.out == 3'd2 ? 1'd1;
      wrapper_early_reset_static_seq4[go] = !wrapper_early_reset_static_seq4[done] & fsm0.out == 3'd3 ? 1'd1;
      fsm0.in = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] ? 3'd1;
      fsm0.write_en = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] ? 3'd2;
      fsm0.write_en = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] ? 3'd3;
      fsm0.write_en = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] ? 1'd1;
      fsm0.in = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] ? 3'd4;
      fsm0.write_en = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] ? 1'd1;
      tdcc[done] = fsm0.out == 3'd4 ? 1'd1;
    }
    signal_reg.write_en = signal_reg.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
    fsm0.in = fsm0.out == 3'd4 ? 3'd0;
    fsm0.write_en = fsm0.out == 3'd4 ? 1'd1;
  }
  control {
    tdcc;
  }
}
Current pass: go-insertion
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated sig_reg = std_reg(1);
  }
  wires {
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    adder.left = fsm.out;
    adder.right = 3'd1;
    fsm.in = fsm.out == 3'd0 & go ? adder.out;
    fsm.write_en = fsm.out == 3'd0 & go ? 1'd1;
    fsm.in = fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.write_en = fsm.out != 3'd0 & fsm.out != 3'd5 ? 1'd1;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    fsm.write_en = fsm.out == 3'd5 ? 1'd1;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
    @generated fsm0 = std_reg(3);
  }
  wires {
    group early_reset_static_par_thread0<"promoted"=1> {
      add0.left = fsm.out == 4'd1 & early_reset_static_par_thread0[go] ? 4'd1;
      add0.right = fsm.out == 4'd1 & early_reset_static_par_thread0[go] ? idx0.out;
      b.addr0 = fsm.out == 4'd0 & early_reset_static_par_thread0[go] ? idx0.out;
      read_b.write_en = fsm.out == 4'd0 & early_reset_static_par_thread0[go] ? 1'd1;
      read_b.in = fsm.out == 4'd0 & early_reset_static_par_thread0[go] ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 & early_reset_static_par_thread0[go] ? 1'd1;
      idx0.in = fsm.out == 4'd1 & early_reset_static_par_thread0[go] ? add0.out;
      a.addr0 = fsm.out == 4'd0 & early_reset_static_par_thread0[go] ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 & early_reset_static_par_thread0[go] ? 1'd1;
      read_a.in = fsm.out == 4'd0 & early_reset_static_par_thread0[go] ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0[go] ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0[go] ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0[go] ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0[go] ? 1'd1;
      early_reset_static_par_thread0[done] = ud.out;
      adder.left = early_reset_static_par_thread0[go] ? fsm.out;
      adder.right = early_reset_static_par_thread0[go] ? 4'd1;
      fsm.in = fsm.out != 4'd6 & early_reset_static_par_thread0[go] ? adder.out;
      fsm.write_en = fsm.out != 4'd6 & early_reset_static_par_thread0[go] ? 1'd1;
      fsm.in = fsm.out == 4'd6 & early_reset_static_par_thread0[go] ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 & early_reset_static_par_thread0[go] ? 1'd1;
    }
    group early_reset_in_range0 {
      comb_reg.write_en = early_reset_in_range0[go] ? 1'd1;
      comb_reg.in = early_reset_in_range0[go] ? lt0.out;
      lt0.left = early_reset_in_range0[go] ? idx0.out;
      lt0.right = early_reset_in_range0[go] ? 4'd10;
      early_reset_in_range0[done] = ud0.out;
    }
    group early_reset_static_seq1 {
      add0.left = fsm.out == 4'd1 & early_reset_static_seq1[go] ? 4'd1;
      add0.right = fsm.out == 4'd1 & early_reset_static_seq1[go] ? idx0.out;
      b.addr0 = fsm.out == 4'd0 & early_reset_static_seq1[go] ? idx0.out;
      comb_reg.write_en = fsm.out == 4'd7 & early_reset_static_seq1[go] ? 1'd1;
      comb_reg.in = fsm.out == 4'd7 & early_reset_static_seq1[go] ? lt0.out;
      read_b.write_en = fsm.out == 4'd0 & early_reset_static_seq1[go] ? 1'd1;
      read_b.in = fsm.out == 4'd0 & early_reset_static_seq1[go] ? b.read_data;
      idx0.write_en = fsm.out == 4'd1 & early_reset_static_seq1[go] ? 1'd1;
      idx0.in = fsm.out == 4'd1 & early_reset_static_seq1[go] ? add0.out;
      a.addr0 = fsm.out == 4'd0 & early_reset_static_seq1[go] ? idx0.out;
      read_a.write_en = fsm.out == 4'd0 & early_reset_static_seq1[go] ? 1'd1;
      read_a.in = fsm.out == 4'd0 & early_reset_static_seq1[go] ? a.read_data;
      mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1[go] ? read_b.out;
      mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1[go] ? 1'd1;
      mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1[go] ? read_a.out;
      mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1[go] ? 1'd1;
      mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1[go] ? mac.out;
      lt0.left = fsm.out == 4'd7 & early_reset_static_seq1[go] ? idx0.out;
      lt0.right = fsm.out == 4'd7 & early_reset_static_seq1[go] ? 4'd10;
      early_reset_static_seq1[done] = ud1.out;
      adder0.left = early_reset_static_seq1[go] ? fsm.out;
      adder0.right = early_reset_static_seq1[go] ? 4'd1;
      fsm.in = fsm.out != 4'd7 & early_reset_static_seq1[go] ? adder0.out;
      fsm.write_en = fsm.out != 4'd7 & early_reset_static_seq1[go] ? 1'd1;
      fsm.in = fsm.out == 4'd7 & early_reset_static_seq1[go] ? 4'd0;
      fsm.write_en = fsm.out == 4'd7 & early_reset_static_seq1[go] ? 1'd1;
    }
    group early_reset_static_seq4 {
      out.write_en = fsm.out == 4'd6 & early_reset_static_seq4[go] ? 1'd1;
      out.addr0 = fsm.out == 4'd6 & early_reset_static_seq4[go] ? 1'd0;
      out.write_data = fsm.out == 4'd6 & early_reset_static_seq4[go] ? mac.out;
      mac.go = fsm.out < 4'd6 & early_reset_static_seq4[go] ? 1'd1;
      mac.c = fsm.out < 4'd6 & early_reset_static_seq4[go] ? mac.out;
      early_reset_static_seq4[done] = ud2.out;
      adder1.left = early_reset_static_seq4[go] ? fsm.out;
      adder1.right = early_reset_static_seq4[go] ? 4'd1;
      fsm.in = fsm.out != 4'd6 & early_reset_static_seq4[go] ? adder1.out;
      fsm.write_en = fsm.out != 4'd6 & early_reset_static_seq4[go] ? 1'd1;
      fsm.in = fsm.out == 4'd6 & early_reset_static_seq4[go] ? 4'd0;
      fsm.write_en = fsm.out == 4'd6 & early_reset_static_seq4[go] ? 1'd1;
    }
    group wrapper_early_reset_static_par_thread0<"promoted"=1> {
      early_reset_static_par_thread0[go] = wrapper_early_reset_static_par_thread0[go] ? 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_par_thread0[go] ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_par_thread0[go] ? 1'd1;
      wrapper_early_reset_static_par_thread0[done] = signal_reg.out ? 1'd1;
    }
    group wrapper_early_reset_in_range0 {
      early_reset_in_range0[go] = wrapper_early_reset_in_range0[go] ? 1'd1;
      signal_reg.write_en = 1'b1 & 1'b1 & !signal_reg.out & wrapper_early_reset_in_range0[go] ? 1'd1;
      signal_reg.in = 1'b1 & 1'b1 & !signal_reg.out & wrapper_early_reset_in_range0[go] ? 1'd1;
      wrapper_early_reset_in_range0[done] = signal_reg.out ? 1'd1;
    }
    group while_wrapper_early_reset_static_seq1 {
      early_reset_static_seq1[go] = while_wrapper_early_reset_static_seq1[go] ? 1'd1;
      while_wrapper_early_reset_static_seq1[done] = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
    }
    group wrapper_early_reset_static_seq4 {
      early_reset_static_seq4[go] = wrapper_early_reset_static_seq4[go] ? 1'd1;
      signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_seq4[go] ? 1'd1;
      signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_seq4[go] ? 1'd1;
      wrapper_early_reset_static_seq4[done] = signal_reg.out ? 1'd1;
    }
    group tdcc {
      wrapper_early_reset_static_par_thread0[go] = !wrapper_early_reset_static_par_thread0[done] & fsm0.out == 3'd0 & tdcc[go] ? 1'd1;
      wrapper_early_reset_in_range0[go] = !wrapper_early_reset_in_range0[done] & fsm0.out == 3'd1 & tdcc[go] ? 1'd1;
      while_wrapper_early_reset_static_seq1[go] = !while_wrapper_early_reset_static_seq1[done] & fsm0.out == 3'd2 & tdcc[go] ? 1'd1;
      wrapper_early_reset_static_seq4[go] = !wrapper_early_reset_static_seq4[done] & fsm0.out == 3'd3 & tdcc[go] ? 1'd1;
      fsm0.in = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] & tdcc[go] ? 3'd1;
      fsm0.write_en = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0[done] & tdcc[go] ? 1'd1;
      fsm0.in = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] & tdcc[go] ? 3'd2;
      fsm0.write_en = fsm0.out == 3'd1 & wrapper_early_reset_in_range0[done] & tdcc[go] ? 1'd1;
      fsm0.in = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] & tdcc[go] ? 3'd3;
      fsm0.write_en = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1[done] & tdcc[go] ? 1'd1;
      fsm0.in = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] & tdcc[go] ? 3'd4;
      fsm0.write_en = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4[done] & tdcc[go] ? 1'd1;
      tdcc[done] = fsm0.out == 3'd4 ? 1'd1;
    }
    signal_reg.write_en = signal_reg.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
    fsm0.in = fsm0.out == 3'd4 ? 3'd0;
    fsm0.write_en = fsm0.out == 3'd4 ? 1'd1;
  }
  control {
    tdcc;
  }
}
Current pass: wire-inliner
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated sig_reg = std_reg(1);
  }
  wires {
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    adder.left = fsm.out;
    adder.right = 3'd1;
    fsm.in = fsm.out == 3'd0 & go ? adder.out;
    fsm.write_en = fsm.out == 3'd0 & go ? 1'd1;
    fsm.in = fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.write_en = fsm.out != 3'd0 & fsm.out != 3'd5 ? 1'd1;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    fsm.write_en = fsm.out == 3'd5 ? 1'd1;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
    @generated fsm0 = std_reg(3);
    @generated early_reset_static_par_thread0_go = std_wire(1);
    @generated early_reset_static_par_thread0_done = std_wire(1);
    @generated early_reset_in_range0_go = std_wire(1);
    @generated early_reset_in_range0_done = std_wire(1);
    @generated early_reset_static_seq1_go = std_wire(1);
    @generated early_reset_static_seq1_done = std_wire(1);
    @generated early_reset_static_seq4_go = std_wire(1);
    @generated early_reset_static_seq4_done = std_wire(1);
    @generated wrapper_early_reset_static_par_thread0_go = std_wire(1);
    @generated wrapper_early_reset_static_par_thread0_done = std_wire(1);
    @generated wrapper_early_reset_in_range0_go = std_wire(1);
    @generated wrapper_early_reset_in_range0_done = std_wire(1);
    @generated while_wrapper_early_reset_static_seq1_go = std_wire(1);
    @generated while_wrapper_early_reset_static_seq1_done = std_wire(1);
    @generated wrapper_early_reset_static_seq4_go = std_wire(1);
    @generated wrapper_early_reset_static_seq4_done = std_wire(1);
    @generated tdcc_go = std_wire(1);
    @generated tdcc_done = std_wire(1);
  }
  wires {
    signal_reg.write_en = signal_reg.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
    fsm0.in = fsm0.out == 3'd4 ? 3'd0;
    fsm0.write_en = fsm0.out == 3'd4 ? 1'd1;
    tdcc_go.in = go;
    done = tdcc_done.out ? 1'd1;
    add0.left = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out ? 4'd1;
    add0.right = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out ? idx0.out;
    b.addr0 = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? idx0.out;
    read_b.write_en = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? 1'd1;
    read_b.in = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? b.read_data;
    idx0.write_en = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out ? 1'd1;
    idx0.in = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out ? add0.out;
    a.addr0 = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? idx0.out;
    read_a.write_en = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? 1'd1;
    read_a.in = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? a.read_data;
    mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out ? read_b.out;
    mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out ? 1'd1;
    mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out ? read_a.out;
    mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out ? 1'd1;
    early_reset_static_par_thread0_done.in = ud.out;
    adder.left = early_reset_static_par_thread0_go.out ? fsm.out;
    adder.right = early_reset_static_par_thread0_go.out ? 4'd1;
    fsm.in = fsm.out != 4'd6 & early_reset_static_par_thread0_go.out ? adder.out;
    fsm.write_en = fsm.out != 4'd6 & early_reset_static_par_thread0_go.out ? 1'd1;
    fsm.in = fsm.out == 4'd6 & early_reset_static_par_thread0_go.out ? 4'd0;
    fsm.write_en = fsm.out == 4'd6 & early_reset_static_par_thread0_go.out ? 1'd1;
    comb_reg.write_en = early_reset_in_range0_go.out ? 1'd1;
    comb_reg.in = early_reset_in_range0_go.out ? lt0.out;
    lt0.left = early_reset_in_range0_go.out ? idx0.out;
    lt0.right = early_reset_in_range0_go.out ? 4'd10;
    early_reset_in_range0_done.in = ud0.out;
    add0.left = fsm.out == 4'd1 & early_reset_static_seq1_go.out ? 4'd1;
    add0.right = fsm.out == 4'd1 & early_reset_static_seq1_go.out ? idx0.out;
    b.addr0 = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? idx0.out;
    comb_reg.write_en = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    comb_reg.in = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? lt0.out;
    read_b.write_en = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? 1'd1;
    read_b.in = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? b.read_data;
    idx0.write_en = fsm.out == 4'd1 & early_reset_static_seq1_go.out ? 1'd1;
    idx0.in = fsm.out == 4'd1 & early_reset_static_seq1_go.out ? add0.out;
    a.addr0 = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? idx0.out;
    read_a.write_en = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? 1'd1;
    read_a.in = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? a.read_data;
    mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? read_b.out;
    mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? read_a.out;
    mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? mac.out;
    lt0.left = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? idx0.out;
    lt0.right = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 4'd10;
    early_reset_static_seq1_done.in = ud1.out;
    adder0.left = early_reset_static_seq1_go.out ? fsm.out;
    adder0.right = early_reset_static_seq1_go.out ? 4'd1;
    fsm.in = fsm.out != 4'd7 & early_reset_static_seq1_go.out ? adder0.out;
    fsm.write_en = fsm.out != 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    fsm.in = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 4'd0;
    fsm.write_en = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    out.write_en = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    out.addr0 = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd0;
    out.write_data = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? mac.out;
    mac.go = fsm.out < 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    mac.c = fsm.out < 4'd6 & early_reset_static_seq4_go.out ? mac.out;
    early_reset_static_seq4_done.in = ud2.out;
    adder1.left = early_reset_static_seq4_go.out ? fsm.out;
    adder1.right = early_reset_static_seq4_go.out ? 4'd1;
    fsm.in = fsm.out != 4'd6 & early_reset_static_seq4_go.out ? adder1.out;
    fsm.write_en = fsm.out != 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    fsm.in = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 4'd0;
    fsm.write_en = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    early_reset_static_par_thread0_go.in = wrapper_early_reset_static_par_thread0_go.out ? 1'd1;
    signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_par_thread0_go.out ? 1'd1;
    signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_par_thread0_go.out ? 1'd1;
    wrapper_early_reset_static_par_thread0_done.in = signal_reg.out ? 1'd1;
    early_reset_in_range0_go.in = wrapper_early_reset_in_range0_go.out ? 1'd1;
    signal_reg.write_en = 1'b1 & 1'b1 & !signal_reg.out & wrapper_early_reset_in_range0_go.out ? 1'd1;
    signal_reg.in = 1'b1 & 1'b1 & !signal_reg.out & wrapper_early_reset_in_range0_go.out ? 1'd1;
    wrapper_early_reset_in_range0_done.in = signal_reg.out ? 1'd1;
    early_reset_static_seq1_go.in = while_wrapper_early_reset_static_seq1_go.out ? 1'd1;
    while_wrapper_early_reset_static_seq1_done.in = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
    early_reset_static_seq4_go.in = wrapper_early_reset_static_seq4_go.out ? 1'd1;
    signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_seq4_go.out ? 1'd1;
    signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_seq4_go.out ? 1'd1;
    wrapper_early_reset_static_seq4_done.in = signal_reg.out ? 1'd1;
    wrapper_early_reset_static_par_thread0_go.in = !wrapper_early_reset_static_par_thread0_done.out & fsm0.out == 3'd0 & tdcc_go.out ? 1'd1;
    wrapper_early_reset_in_range0_go.in = !wrapper_early_reset_in_range0_done.out & fsm0.out == 3'd1 & tdcc_go.out ? 1'd1;
    while_wrapper_early_reset_static_seq1_go.in = !while_wrapper_early_reset_static_seq1_done.out & fsm0.out == 3'd2 & tdcc_go.out ? 1'd1;
    wrapper_early_reset_static_seq4_go.in = !wrapper_early_reset_static_seq4_done.out & fsm0.out == 3'd3 & tdcc_go.out ? 1'd1;
    fsm0.in = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0_done.out & tdcc_go.out ? 3'd1;
    fsm0.write_en = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0_done.out & tdcc_go.out ? 1'd1;
    fsm0.in = fsm0.out == 3'd1 & wrapper_early_reset_in_range0_done.out & tdcc_go.out ? 3'd2;
    fsm0.write_en = fsm0.out == 3'd1 & wrapper_early_reset_in_range0_done.out & tdcc_go.out ? 1'd1;
    fsm0.in = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1_done.out & tdcc_go.out ? 3'd3;
    fsm0.write_en = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1_done.out & tdcc_go.out ? 1'd1;
    fsm0.in = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4_done.out & tdcc_go.out ? 3'd4;
    fsm0.write_en = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4_done.out & tdcc_go.out ? 1'd1;
    tdcc_done.in = fsm0.out == 3'd4 ? 1'd1;
  }
  control {}
}
Current pass: clk-insertion
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated sig_reg = std_reg(1);
  }
  wires {
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    adder.left = fsm.out;
    adder.right = 3'd1;
    fsm.in = fsm.out == 3'd0 & go ? adder.out;
    fsm.write_en = fsm.out == 3'd0 & go ? 1'd1;
    fsm.in = fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.write_en = fsm.out != 3'd0 & fsm.out != 3'd5 ? 1'd1;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    fsm.write_en = fsm.out == 3'd5 ? 1'd1;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
    mult_pipe.clk = clk;
    pipe1.clk = clk;
    pipe2.clk = clk;
    stage2_valid.clk = clk;
    out_valid.clk = clk;
    data_valid_reg.clk = clk;
    cond.clk = clk;
    fsm.clk = clk;
    sig_reg.clk = clk;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
    @generated fsm0 = std_reg(3);
    @generated early_reset_static_par_thread0_go = std_wire(1);
    @generated early_reset_static_par_thread0_done = std_wire(1);
    @generated early_reset_in_range0_go = std_wire(1);
    @generated early_reset_in_range0_done = std_wire(1);
    @generated early_reset_static_seq1_go = std_wire(1);
    @generated early_reset_static_seq1_done = std_wire(1);
    @generated early_reset_static_seq4_go = std_wire(1);
    @generated early_reset_static_seq4_done = std_wire(1);
    @generated wrapper_early_reset_static_par_thread0_go = std_wire(1);
    @generated wrapper_early_reset_static_par_thread0_done = std_wire(1);
    @generated wrapper_early_reset_in_range0_go = std_wire(1);
    @generated wrapper_early_reset_in_range0_done = std_wire(1);
    @generated while_wrapper_early_reset_static_seq1_go = std_wire(1);
    @generated while_wrapper_early_reset_static_seq1_done = std_wire(1);
    @generated wrapper_early_reset_static_seq4_go = std_wire(1);
    @generated wrapper_early_reset_static_seq4_done = std_wire(1);
    @generated tdcc_go = std_wire(1);
    @generated tdcc_done = std_wire(1);
  }
  wires {
    signal_reg.write_en = signal_reg.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
    fsm0.in = fsm0.out == 3'd4 ? 3'd0;
    fsm0.write_en = fsm0.out == 3'd4 ? 1'd1;
    tdcc_go.in = go;
    done = tdcc_done.out ? 1'd1;
    add0.left = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out ? 4'd1;
    add0.right = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out ? idx0.out;
    b.addr0 = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? idx0.out;
    read_b.write_en = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? 1'd1;
    read_b.in = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? b.read_data;
    idx0.write_en = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out ? 1'd1;
    idx0.in = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out ? add0.out;
    a.addr0 = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? idx0.out;
    read_a.write_en = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? 1'd1;
    read_a.in = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? a.read_data;
    mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out ? read_b.out;
    mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out ? 1'd1;
    mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out ? read_a.out;
    mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out ? 1'd1;
    early_reset_static_par_thread0_done.in = ud.out;
    adder.left = early_reset_static_par_thread0_go.out ? fsm.out;
    adder.right = early_reset_static_par_thread0_go.out ? 4'd1;
    fsm.in = fsm.out != 4'd6 & early_reset_static_par_thread0_go.out ? adder.out;
    fsm.write_en = fsm.out != 4'd6 & early_reset_static_par_thread0_go.out ? 1'd1;
    fsm.in = fsm.out == 4'd6 & early_reset_static_par_thread0_go.out ? 4'd0;
    fsm.write_en = fsm.out == 4'd6 & early_reset_static_par_thread0_go.out ? 1'd1;
    comb_reg.write_en = early_reset_in_range0_go.out ? 1'd1;
    comb_reg.in = early_reset_in_range0_go.out ? lt0.out;
    lt0.left = early_reset_in_range0_go.out ? idx0.out;
    lt0.right = early_reset_in_range0_go.out ? 4'd10;
    early_reset_in_range0_done.in = ud0.out;
    add0.left = fsm.out == 4'd1 & early_reset_static_seq1_go.out ? 4'd1;
    add0.right = fsm.out == 4'd1 & early_reset_static_seq1_go.out ? idx0.out;
    b.addr0 = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? idx0.out;
    comb_reg.write_en = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    comb_reg.in = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? lt0.out;
    read_b.write_en = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? 1'd1;
    read_b.in = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? b.read_data;
    idx0.write_en = fsm.out == 4'd1 & early_reset_static_seq1_go.out ? 1'd1;
    idx0.in = fsm.out == 4'd1 & early_reset_static_seq1_go.out ? add0.out;
    a.addr0 = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? idx0.out;
    read_a.write_en = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? 1'd1;
    read_a.in = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? a.read_data;
    mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? read_b.out;
    mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? read_a.out;
    mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? mac.out;
    lt0.left = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? idx0.out;
    lt0.right = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 4'd10;
    early_reset_static_seq1_done.in = ud1.out;
    adder0.left = early_reset_static_seq1_go.out ? fsm.out;
    adder0.right = early_reset_static_seq1_go.out ? 4'd1;
    fsm.in = fsm.out != 4'd7 & early_reset_static_seq1_go.out ? adder0.out;
    fsm.write_en = fsm.out != 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    fsm.in = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 4'd0;
    fsm.write_en = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    out.write_en = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    out.addr0 = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd0;
    out.write_data = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? mac.out;
    mac.go = fsm.out < 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    mac.c = fsm.out < 4'd6 & early_reset_static_seq4_go.out ? mac.out;
    early_reset_static_seq4_done.in = ud2.out;
    adder1.left = early_reset_static_seq4_go.out ? fsm.out;
    adder1.right = early_reset_static_seq4_go.out ? 4'd1;
    fsm.in = fsm.out != 4'd6 & early_reset_static_seq4_go.out ? adder1.out;
    fsm.write_en = fsm.out != 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    fsm.in = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 4'd0;
    fsm.write_en = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    early_reset_static_par_thread0_go.in = wrapper_early_reset_static_par_thread0_go.out ? 1'd1;
    signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_par_thread0_go.out ? 1'd1;
    signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_par_thread0_go.out ? 1'd1;
    wrapper_early_reset_static_par_thread0_done.in = signal_reg.out ? 1'd1;
    early_reset_in_range0_go.in = wrapper_early_reset_in_range0_go.out ? 1'd1;
    signal_reg.write_en = 1'b1 & 1'b1 & !signal_reg.out & wrapper_early_reset_in_range0_go.out ? 1'd1;
    signal_reg.in = 1'b1 & 1'b1 & !signal_reg.out & wrapper_early_reset_in_range0_go.out ? 1'd1;
    wrapper_early_reset_in_range0_done.in = signal_reg.out ? 1'd1;
    early_reset_static_seq1_go.in = while_wrapper_early_reset_static_seq1_go.out ? 1'd1;
    while_wrapper_early_reset_static_seq1_done.in = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
    early_reset_static_seq4_go.in = wrapper_early_reset_static_seq4_go.out ? 1'd1;
    signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_seq4_go.out ? 1'd1;
    signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_seq4_go.out ? 1'd1;
    wrapper_early_reset_static_seq4_done.in = signal_reg.out ? 1'd1;
    wrapper_early_reset_static_par_thread0_go.in = !wrapper_early_reset_static_par_thread0_done.out & fsm0.out == 3'd0 & tdcc_go.out ? 1'd1;
    wrapper_early_reset_in_range0_go.in = !wrapper_early_reset_in_range0_done.out & fsm0.out == 3'd1 & tdcc_go.out ? 1'd1;
    while_wrapper_early_reset_static_seq1_go.in = !while_wrapper_early_reset_static_seq1_done.out & fsm0.out == 3'd2 & tdcc_go.out ? 1'd1;
    wrapper_early_reset_static_seq4_go.in = !wrapper_early_reset_static_seq4_done.out & fsm0.out == 3'd3 & tdcc_go.out ? 1'd1;
    fsm0.in = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0_done.out & tdcc_go.out ? 3'd1;
    fsm0.write_en = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0_done.out & tdcc_go.out ? 1'd1;
    fsm0.in = fsm0.out == 3'd1 & wrapper_early_reset_in_range0_done.out & tdcc_go.out ? 3'd2;
    fsm0.write_en = fsm0.out == 3'd1 & wrapper_early_reset_in_range0_done.out & tdcc_go.out ? 1'd1;
    fsm0.in = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1_done.out & tdcc_go.out ? 3'd3;
    fsm0.write_en = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1_done.out & tdcc_go.out ? 1'd1;
    fsm0.in = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4_done.out & tdcc_go.out ? 3'd4;
    fsm0.write_en = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4_done.out & tdcc_go.out ? 1'd1;
    tdcc_done.in = fsm0.out == 3'd4 ? 1'd1;
    a.clk = clk;
    b.clk = clk;
    out.clk = clk;
    read_a.clk = clk;
    read_b.clk = clk;
    idx0.clk = clk;
    mac.clk = clk;
    comb_reg.clk = clk;
    fsm.clk = clk;
    signal_reg.clk = clk;
    fsm0.clk = clk;
  }
  control {}
}
Current pass: reset-insertion
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated sig_reg = std_reg(1);
  }
  wires {
    out = pipe2.out;
    output_valid = out_valid.out;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    adder.left = fsm.out;
    adder.right = 3'd1;
    fsm.in = fsm.out == 3'd0 & go ? adder.out;
    fsm.write_en = fsm.out == 3'd0 & go ? 1'd1;
    fsm.in = fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.write_en = fsm.out != 3'd0 & fsm.out != 3'd5 ? 1'd1;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    fsm.write_en = fsm.out == 3'd5 ? 1'd1;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
    mult_pipe.clk = clk;
    pipe1.clk = clk;
    pipe2.clk = clk;
    stage2_valid.clk = clk;
    out_valid.clk = clk;
    data_valid_reg.clk = clk;
    cond.clk = clk;
    fsm.clk = clk;
    sig_reg.clk = clk;
    mult_pipe.reset = reset;
    pipe1.reset = reset;
    pipe2.reset = reset;
    stage2_valid.reset = reset;
    out_valid.reset = reset;
    data_valid_reg.reset = reset;
    cond.reset = reset;
    fsm.reset = reset;
    sig_reg.reset = reset;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
    @generated fsm0 = std_reg(3);
    @generated early_reset_static_par_thread0_go = std_wire(1);
    @generated early_reset_static_par_thread0_done = std_wire(1);
    @generated early_reset_in_range0_go = std_wire(1);
    @generated early_reset_in_range0_done = std_wire(1);
    @generated early_reset_static_seq1_go = std_wire(1);
    @generated early_reset_static_seq1_done = std_wire(1);
    @generated early_reset_static_seq4_go = std_wire(1);
    @generated early_reset_static_seq4_done = std_wire(1);
    @generated wrapper_early_reset_static_par_thread0_go = std_wire(1);
    @generated wrapper_early_reset_static_par_thread0_done = std_wire(1);
    @generated wrapper_early_reset_in_range0_go = std_wire(1);
    @generated wrapper_early_reset_in_range0_done = std_wire(1);
    @generated while_wrapper_early_reset_static_seq1_go = std_wire(1);
    @generated while_wrapper_early_reset_static_seq1_done = std_wire(1);
    @generated wrapper_early_reset_static_seq4_go = std_wire(1);
    @generated wrapper_early_reset_static_seq4_done = std_wire(1);
    @generated tdcc_go = std_wire(1);
    @generated tdcc_done = std_wire(1);
  }
  wires {
    signal_reg.write_en = signal_reg.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
    fsm0.in = fsm0.out == 3'd4 ? 3'd0;
    fsm0.write_en = fsm0.out == 3'd4 ? 1'd1;
    tdcc_go.in = go;
    done = tdcc_done.out ? 1'd1;
    add0.left = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out ? 4'd1;
    add0.right = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out ? idx0.out;
    b.addr0 = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? idx0.out;
    read_b.write_en = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? 1'd1;
    read_b.in = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? b.read_data;
    idx0.write_en = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out ? 1'd1;
    idx0.in = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out ? add0.out;
    a.addr0 = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? idx0.out;
    read_a.write_en = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? 1'd1;
    read_a.in = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out ? a.read_data;
    mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out ? read_b.out;
    mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out ? 1'd1;
    mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out ? read_a.out;
    mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out ? 1'd1;
    early_reset_static_par_thread0_done.in = ud.out;
    adder.left = early_reset_static_par_thread0_go.out ? fsm.out;
    adder.right = early_reset_static_par_thread0_go.out ? 4'd1;
    fsm.in = fsm.out != 4'd6 & early_reset_static_par_thread0_go.out ? adder.out;
    fsm.write_en = fsm.out != 4'd6 & early_reset_static_par_thread0_go.out ? 1'd1;
    fsm.in = fsm.out == 4'd6 & early_reset_static_par_thread0_go.out ? 4'd0;
    fsm.write_en = fsm.out == 4'd6 & early_reset_static_par_thread0_go.out ? 1'd1;
    comb_reg.write_en = early_reset_in_range0_go.out ? 1'd1;
    comb_reg.in = early_reset_in_range0_go.out ? lt0.out;
    lt0.left = early_reset_in_range0_go.out ? idx0.out;
    lt0.right = early_reset_in_range0_go.out ? 4'd10;
    early_reset_in_range0_done.in = ud0.out;
    add0.left = fsm.out == 4'd1 & early_reset_static_seq1_go.out ? 4'd1;
    add0.right = fsm.out == 4'd1 & early_reset_static_seq1_go.out ? idx0.out;
    b.addr0 = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? idx0.out;
    comb_reg.write_en = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    comb_reg.in = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? lt0.out;
    read_b.write_en = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? 1'd1;
    read_b.in = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? b.read_data;
    idx0.write_en = fsm.out == 4'd1 & early_reset_static_seq1_go.out ? 1'd1;
    idx0.in = fsm.out == 4'd1 & early_reset_static_seq1_go.out ? add0.out;
    a.addr0 = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? idx0.out;
    read_a.write_en = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? 1'd1;
    read_a.in = fsm.out == 4'd0 & early_reset_static_seq1_go.out ? a.read_data;
    mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? read_b.out;
    mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? read_a.out;
    mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? mac.out;
    lt0.left = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? idx0.out;
    lt0.right = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 4'd10;
    early_reset_static_seq1_done.in = ud1.out;
    adder0.left = early_reset_static_seq1_go.out ? fsm.out;
    adder0.right = early_reset_static_seq1_go.out ? 4'd1;
    fsm.in = fsm.out != 4'd7 & early_reset_static_seq1_go.out ? adder0.out;
    fsm.write_en = fsm.out != 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    fsm.in = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 4'd0;
    fsm.write_en = fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    out.write_en = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    out.addr0 = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd0;
    out.write_data = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? mac.out;
    mac.go = fsm.out < 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    mac.c = fsm.out < 4'd6 & early_reset_static_seq4_go.out ? mac.out;
    early_reset_static_seq4_done.in = ud2.out;
    adder1.left = early_reset_static_seq4_go.out ? fsm.out;
    adder1.right = early_reset_static_seq4_go.out ? 4'd1;
    fsm.in = fsm.out != 4'd6 & early_reset_static_seq4_go.out ? adder1.out;
    fsm.write_en = fsm.out != 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    fsm.in = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 4'd0;
    fsm.write_en = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    early_reset_static_par_thread0_go.in = wrapper_early_reset_static_par_thread0_go.out ? 1'd1;
    signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_par_thread0_go.out ? 1'd1;
    signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_par_thread0_go.out ? 1'd1;
    wrapper_early_reset_static_par_thread0_done.in = signal_reg.out ? 1'd1;
    early_reset_in_range0_go.in = wrapper_early_reset_in_range0_go.out ? 1'd1;
    signal_reg.write_en = 1'b1 & 1'b1 & !signal_reg.out & wrapper_early_reset_in_range0_go.out ? 1'd1;
    signal_reg.in = 1'b1 & 1'b1 & !signal_reg.out & wrapper_early_reset_in_range0_go.out ? 1'd1;
    wrapper_early_reset_in_range0_done.in = signal_reg.out ? 1'd1;
    early_reset_static_seq1_go.in = while_wrapper_early_reset_static_seq1_go.out ? 1'd1;
    while_wrapper_early_reset_static_seq1_done.in = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
    early_reset_static_seq4_go.in = wrapper_early_reset_static_seq4_go.out ? 1'd1;
    signal_reg.write_en = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_seq4_go.out ? 1'd1;
    signal_reg.in = fsm.out == 4'd6 & 1'b1 & !signal_reg.out & wrapper_early_reset_static_seq4_go.out ? 1'd1;
    wrapper_early_reset_static_seq4_done.in = signal_reg.out ? 1'd1;
    wrapper_early_reset_static_par_thread0_go.in = !wrapper_early_reset_static_par_thread0_done.out & fsm0.out == 3'd0 & tdcc_go.out ? 1'd1;
    wrapper_early_reset_in_range0_go.in = !wrapper_early_reset_in_range0_done.out & fsm0.out == 3'd1 & tdcc_go.out ? 1'd1;
    while_wrapper_early_reset_static_seq1_go.in = !while_wrapper_early_reset_static_seq1_done.out & fsm0.out == 3'd2 & tdcc_go.out ? 1'd1;
    wrapper_early_reset_static_seq4_go.in = !wrapper_early_reset_static_seq4_done.out & fsm0.out == 3'd3 & tdcc_go.out ? 1'd1;
    fsm0.in = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0_done.out & tdcc_go.out ? 3'd1;
    fsm0.write_en = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0_done.out & tdcc_go.out ? 1'd1;
    fsm0.in = fsm0.out == 3'd1 & wrapper_early_reset_in_range0_done.out & tdcc_go.out ? 3'd2;
    fsm0.write_en = fsm0.out == 3'd1 & wrapper_early_reset_in_range0_done.out & tdcc_go.out ? 1'd1;
    fsm0.in = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1_done.out & tdcc_go.out ? 3'd3;
    fsm0.write_en = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1_done.out & tdcc_go.out ? 1'd1;
    fsm0.in = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4_done.out & tdcc_go.out ? 3'd4;
    fsm0.write_en = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4_done.out & tdcc_go.out ? 1'd1;
    tdcc_done.in = fsm0.out == 3'd4 ? 1'd1;
    a.clk = clk;
    b.clk = clk;
    out.clk = clk;
    read_a.clk = clk;
    read_b.clk = clk;
    idx0.clk = clk;
    mac.clk = clk;
    comb_reg.clk = clk;
    fsm.clk = clk;
    signal_reg.clk = clk;
    fsm0.clk = clk;
    a.reset = reset;
    b.reset = reset;
    out.reset = reset;
    read_a.reset = reset;
    read_b.reset = reset;
    idx0.reset = reset;
    mac.reset = reset;
    comb_reg.reset = reset;
    fsm.reset = reset;
    signal_reg.reset = reset;
    fsm0.reset = reset;
  }
  control {}
}
Current pass: merge-assigns
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated sig_reg = std_reg(1);
  }
  wires {
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
    out = pipe2.out;
    output_valid = out_valid.out;
    fsm.write_en = fsm.out == 3'd0 & go | fsm.out != 3'd0 & fsm.out != 3'd5 | fsm.out == 3'd5 ? 1'd1;
    fsm.clk = clk;
    fsm.reset = reset;
    fsm.in = fsm.out == 3'd0 & go | fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    adder.left = fsm.out;
    adder.right = 3'd1;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.clk = clk;
    cond.reset = reset;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.clk = clk;
    pipe2.reset = reset;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.clk = clk;
    out_valid.reset = reset;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.clk = clk;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.reset = reset;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.clk = clk;
    data_valid_reg.reset = reset;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.clk = clk;
    stage2_valid.reset = reset;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.clk = clk;
    pipe1.reset = reset;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.clk = clk;
    sig_reg.reset = reset;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
    @generated fsm0 = std_reg(3);
    @generated early_reset_static_par_thread0_go = std_wire(1);
    @generated early_reset_static_par_thread0_done = std_wire(1);
    @generated early_reset_in_range0_go = std_wire(1);
    @generated early_reset_in_range0_done = std_wire(1);
    @generated early_reset_static_seq1_go = std_wire(1);
    @generated early_reset_static_seq1_done = std_wire(1);
    @generated early_reset_static_seq4_go = std_wire(1);
    @generated early_reset_static_seq4_done = std_wire(1);
    @generated wrapper_early_reset_static_par_thread0_go = std_wire(1);
    @generated wrapper_early_reset_static_par_thread0_done = std_wire(1);
    @generated wrapper_early_reset_in_range0_go = std_wire(1);
    @generated wrapper_early_reset_in_range0_done = std_wire(1);
    @generated while_wrapper_early_reset_static_seq1_go = std_wire(1);
    @generated while_wrapper_early_reset_static_seq1_done = std_wire(1);
    @generated wrapper_early_reset_static_seq4_go = std_wire(1);
    @generated wrapper_early_reset_static_seq4_done = std_wire(1);
    @generated tdcc_go = std_wire(1);
    @generated tdcc_done = std_wire(1);
  }
  wires {
    adder1.left = early_reset_static_seq4_go.out ? fsm.out;
    adder1.right = early_reset_static_seq4_go.out ? 4'd1;
    wrapper_early_reset_in_range0_done.in = signal_reg.out ? 1'd1;
    done = tdcc_done.out ? 1'd1;
    fsm.write_en = fsm.out != 4'd6 & early_reset_static_par_thread0_go.out | fsm.out == 4'd6 & early_reset_static_par_thread0_go.out | fsm.out != 4'd7 & early_reset_static_seq1_go.out | fsm.out == 4'd7 & early_reset_static_seq1_go.out | fsm.out != 4'd6 & early_reset_static_seq4_go.out | fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    fsm.clk = clk;
    fsm.reset = reset;
    fsm.in = fsm.out != 4'd6 & early_reset_static_seq4_go.out ? adder1.out;
    fsm.in = fsm.out != 4'd6 & early_reset_static_par_thread0_go.out ? adder.out;
    fsm.in = fsm.out == 4'd6 & early_reset_static_par_thread0_go.out | fsm.out == 4'd7 & early_reset_static_seq1_go.out | fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 4'd0;
    fsm.in = fsm.out != 4'd7 & early_reset_static_seq1_go.out ? adder0.out;
    adder.left = early_reset_static_par_thread0_go.out ? fsm.out;
    adder.right = early_reset_static_par_thread0_go.out ? 4'd1;
    wrapper_early_reset_static_seq4_done.in = signal_reg.out ? 1'd1;
    add0.left = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out | fsm.out == 4'd1 & early_reset_static_seq1_go.out ? 4'd1;
    add0.right = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out | fsm.out == 4'd1 & early_reset_static_seq1_go.out ? idx0.out;
    b.clk = clk;
    b.addr0 = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out | fsm.out == 4'd0 & early_reset_static_seq1_go.out ? idx0.out;
    b.reset = reset;
    comb_reg.write_en = early_reset_in_range0_go.out | fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    comb_reg.clk = clk;
    comb_reg.reset = reset;
    comb_reg.in = early_reset_in_range0_go.out | fsm.out == 4'd7 & early_reset_static_seq1_go.out ? lt0.out;
    early_reset_static_par_thread0_done.in = ud.out;
    early_reset_static_seq4_go.in = wrapper_early_reset_static_seq4_go.out ? 1'd1;
    while_wrapper_early_reset_static_seq1_go.in = !while_wrapper_early_reset_static_seq1_done.out & fsm0.out == 3'd2 & tdcc_go.out ? 1'd1;
    read_b.write_en = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out | fsm.out == 4'd0 & early_reset_static_seq1_go.out ? 1'd1;
    read_b.clk = clk;
    read_b.reset = reset;
    read_b.in = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out | fsm.out == 4'd0 & early_reset_static_seq1_go.out ? b.read_data;
    idx0.write_en = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out | fsm.out == 4'd1 & early_reset_static_seq1_go.out ? 1'd1;
    idx0.clk = clk;
    idx0.reset = reset;
    idx0.in = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out | fsm.out == 4'd1 & early_reset_static_seq1_go.out ? add0.out;
    early_reset_static_seq1_done.in = ud1.out;
    a.clk = clk;
    a.addr0 = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out | fsm.out == 4'd0 & early_reset_static_seq1_go.out ? idx0.out;
    a.reset = reset;
    out.write_en = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    out.clk = clk;
    out.addr0 = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd0;
    out.reset = reset;
    out.write_data = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? mac.out;
    early_reset_static_seq1_go.in = while_wrapper_early_reset_static_seq1_go.out ? 1'd1;
    tdcc_go.in = go;
    fsm0.write_en = fsm0.out == 3'd4 | fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0_done.out & tdcc_go.out | fsm0.out == 3'd1 & wrapper_early_reset_in_range0_done.out & tdcc_go.out | fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1_done.out & tdcc_go.out | fsm0.out == 3'd3 & wrapper_early_reset_static_seq4_done.out & tdcc_go.out ? 1'd1;
    fsm0.clk = clk;
    fsm0.reset = reset;
    fsm0.in = fsm0.out == 3'd1 & wrapper_early_reset_in_range0_done.out & tdcc_go.out ? 3'd2;
    fsm0.in = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4_done.out & tdcc_go.out ? 3'd4;
    fsm0.in = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0_done.out & tdcc_go.out ? 3'd1;
    fsm0.in = fsm0.out == 3'd4 ? 3'd0;
    fsm0.in = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1_done.out & tdcc_go.out ? 3'd3;
    adder0.left = early_reset_static_seq1_go.out ? fsm.out;
    adder0.right = early_reset_static_seq1_go.out ? 4'd1;
    wrapper_early_reset_static_par_thread0_go.in = !wrapper_early_reset_static_par_thread0_done.out & fsm0.out == 3'd0 & tdcc_go.out ? 1'd1;
    read_a.write_en = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out | fsm.out == 4'd0 & early_reset_static_seq1_go.out ? 1'd1;
    read_a.clk = clk;
    read_a.reset = reset;
    read_a.in = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out | fsm.out == 4'd0 & early_reset_static_seq1_go.out ? a.read_data;
    signal_reg.write_en = signal_reg.out | fsm.out == 4'd6 & !signal_reg.out & wrapper_early_reset_static_par_thread0_go.out | !signal_reg.out & wrapper_early_reset_in_range0_go.out | fsm.out == 4'd6 & !signal_reg.out & wrapper_early_reset_static_seq4_go.out ? 1'd1;
    signal_reg.clk = clk;
    signal_reg.reset = reset;
    signal_reg.in = fsm.out == 4'd6 & !signal_reg.out & wrapper_early_reset_static_par_thread0_go.out | !signal_reg.out & wrapper_early_reset_in_range0_go.out | fsm.out == 4'd6 & !signal_reg.out & wrapper_early_reset_static_seq4_go.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
    wrapper_early_reset_static_par_thread0_done.in = signal_reg.out ? 1'd1;
    early_reset_static_par_thread0_go.in = wrapper_early_reset_static_par_thread0_go.out ? 1'd1;
    early_reset_static_seq4_done.in = ud2.out;
    wrapper_early_reset_in_range0_go.in = !wrapper_early_reset_in_range0_done.out & fsm0.out == 3'd1 & tdcc_go.out ? 1'd1;
    tdcc_done.in = fsm0.out == 3'd4 ? 1'd1;
    mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out | fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? read_b.out;
    mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out | fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    mac.clk = clk;
    mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out | fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? read_a.out;
    mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out | fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out | fsm.out < 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    mac.reset = reset;
    mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out | fsm.out < 4'd6 & early_reset_static_seq4_go.out ? mac.out;
    early_reset_in_range0_go.in = wrapper_early_reset_in_range0_go.out ? 1'd1;
    wrapper_early_reset_static_seq4_go.in = !wrapper_early_reset_static_seq4_done.out & fsm0.out == 3'd3 & tdcc_go.out ? 1'd1;
    lt0.left = early_reset_in_range0_go.out | fsm.out == 4'd7 & early_reset_static_seq1_go.out ? idx0.out;
    lt0.right = early_reset_in_range0_go.out | fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 4'd10;
    early_reset_in_range0_done.in = ud0.out;
    while_wrapper_early_reset_static_seq1_done.in = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
  }
  control {}
}
Current pass: default-assigns
static<6> component pipelined_mac<"promoted"=1>(data_valid: 1, @data a: 32, @data b: 32, @data c: 32, @go go: 1, @clk clk: 1, @reset reset: 1) -> (@data out: 32, output_valid: 1, @done done: 1) {
  cells {
    @data mult_pipe = std_mult_pipe(32);
    @data add = std_add(32);
    @data pipe1 = std_reg(32);
    @data pipe2 = std_reg(32);
    @data stage2_valid = std_reg(1);
    @data out_valid = std_reg(1);
    @data data_valid_reg = std_reg(1);
    @generated cond = std_reg(1);
    @generated cond_wire = std_wire(1);
    @generated fsm = std_reg(3);
    @generated adder = std_add(3);
    @generated sig_reg = std_reg(1);
  }
  wires {
    done = fsm.out == 3'd0 & 1'b1 & sig_reg.out ? 1'd1;
    out = pipe2.out;
    output_valid = out_valid.out;
    fsm.write_en = fsm.out == 3'd0 & go | fsm.out != 3'd0 & fsm.out != 3'd5 | fsm.out == 3'd5 ? 1'd1;
    fsm.clk = clk;
    fsm.reset = reset;
    fsm.in = fsm.out == 3'd0 & go | fsm.out != 3'd0 & fsm.out != 3'd5 ? adder.out;
    fsm.in = fsm.out == 3'd5 ? 3'd0;
    adder.left = fsm.out;
    adder.right = 3'd1;
    cond.write_en = fsm.out == 3'd1 ? 1'd1;
    cond.clk = clk;
    cond.reset = reset;
    cond.in = fsm.out >= 3'd1 & fsm.out < 3'd5 ? data_valid_reg.out;
    pipe2.write_en = stage2_valid.out & fsm.out == 3'd1 ? 1'd1;
    pipe2.clk = clk;
    pipe2.reset = reset;
    pipe2.in = stage2_valid.out & fsm.out == 3'd1 ? add.out;
    out_valid.write_en = stage2_valid.out & fsm.out == 3'd5 | !stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.clk = clk;
    out_valid.reset = reset;
    out_valid.in = stage2_valid.out & fsm.out == 3'd5 ? 1'd1;
    out_valid.in = !stage2_valid.out & fsm.out == 3'd5 ? 1'd0;
    mult_pipe.clk = clk;
    mult_pipe.left = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? a;
    mult_pipe.go = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? 1'd1;
    mult_pipe.reset = reset;
    mult_pipe.right = cond_wire.out & fsm.out >= 3'd1 & fsm.out < 3'd4 ? b;
    data_valid_reg.write_en = go & fsm.out == 3'd0 ? 1'd1;
    data_valid_reg.clk = clk;
    data_valid_reg.reset = reset;
    data_valid_reg.in = go & fsm.out == 3'd0 ? data_valid;
    add.left = stage2_valid.out & fsm.out == 3'd1 ? pipe1.out;
    add.right = stage2_valid.out & fsm.out == 3'd1 ? c;
    stage2_valid.write_en = data_valid_reg.out & fsm.out == 3'd5 | !data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.clk = clk;
    stage2_valid.reset = reset;
    stage2_valid.in = data_valid_reg.out & fsm.out == 3'd5 ? 1'd1;
    stage2_valid.in = !data_valid_reg.out & fsm.out == 3'd5 ? 1'd0;
    cond_wire.in = fsm.out >= 3'd2 & fsm.out < 3'd5 ? cond.out;
    cond_wire.in = fsm.out == 3'd1 ? data_valid_reg.out;
    pipe1.write_en = cond_wire.out & fsm.out == 3'd4 ? 1'd1;
    pipe1.clk = clk;
    pipe1.reset = reset;
    pipe1.in = cond_wire.out & fsm.out == 3'd4 ? mult_pipe.out;
    sig_reg.write_en = fsm.out == 3'd0 & 1'b1 ? 1'd1;
    sig_reg.clk = clk;
    sig_reg.reset = reset;
    sig_reg.in = go ? 1'd1;
    sig_reg.in = !go ? 1'd0;
  }
  control {}
}
component main(@go go: 1, @clk clk: 1, @reset reset: 1) -> (@done done: 1) {
  cells {
    @external @data a = comb_mem_d1(32, 10, 4);
    @external @data b = comb_mem_d1(32, 10, 4);
    @external @data out = comb_mem_d1(32, 1, 1);
    @data read_a = std_reg(32);
    @data read_b = std_reg(32);
    @data idx0 = std_reg(4);
    @data add0 = std_add(4);
    @control lt0 = std_lt(4);
    @data mac = pipelined_mac();
    @generated comb_reg = std_reg(1);
    @generated fsm = std_reg(4);
    @generated adder = std_add(4);
    @generated ud = undef(1);
    @generated ud0 = undef(1);
    @generated adder0 = std_add(4);
    @generated ud1 = undef(1);
    @generated adder1 = std_add(4);
    @generated ud2 = undef(1);
    @generated signal_reg = std_reg(1);
    @generated fsm0 = std_reg(3);
    @generated early_reset_static_par_thread0_go = std_wire(1);
    @generated early_reset_static_par_thread0_done = std_wire(1);
    @generated early_reset_in_range0_go = std_wire(1);
    @generated early_reset_in_range0_done = std_wire(1);
    @generated early_reset_static_seq1_go = std_wire(1);
    @generated early_reset_static_seq1_done = std_wire(1);
    @generated early_reset_static_seq4_go = std_wire(1);
    @generated early_reset_static_seq4_done = std_wire(1);
    @generated wrapper_early_reset_static_par_thread0_go = std_wire(1);
    @generated wrapper_early_reset_static_par_thread0_done = std_wire(1);
    @generated wrapper_early_reset_in_range0_go = std_wire(1);
    @generated wrapper_early_reset_in_range0_done = std_wire(1);
    @generated while_wrapper_early_reset_static_seq1_go = std_wire(1);
    @generated while_wrapper_early_reset_static_seq1_done = std_wire(1);
    @generated wrapper_early_reset_static_seq4_go = std_wire(1);
    @generated wrapper_early_reset_static_seq4_done = std_wire(1);
    @generated tdcc_go = std_wire(1);
    @generated tdcc_done = std_wire(1);
  }
  wires {
    adder1.left = early_reset_static_seq4_go.out ? fsm.out;
    adder1.right = early_reset_static_seq4_go.out ? 4'd1;
    wrapper_early_reset_in_range0_done.in = signal_reg.out ? 1'd1;
    done = tdcc_done.out ? 1'd1;
    fsm.write_en = fsm.out != 4'd6 & early_reset_static_par_thread0_go.out | fsm.out == 4'd6 & early_reset_static_par_thread0_go.out | fsm.out != 4'd7 & early_reset_static_seq1_go.out | fsm.out == 4'd7 & early_reset_static_seq1_go.out | fsm.out != 4'd6 & early_reset_static_seq4_go.out | fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    fsm.clk = clk;
    fsm.reset = reset;
    fsm.in = fsm.out != 4'd6 & early_reset_static_seq4_go.out ? adder1.out;
    fsm.in = fsm.out != 4'd6 & early_reset_static_par_thread0_go.out ? adder.out;
    fsm.in = fsm.out == 4'd6 & early_reset_static_par_thread0_go.out | fsm.out == 4'd7 & early_reset_static_seq1_go.out | fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 4'd0;
    fsm.in = fsm.out != 4'd7 & early_reset_static_seq1_go.out ? adder0.out;
    adder.left = early_reset_static_par_thread0_go.out ? fsm.out;
    adder.right = early_reset_static_par_thread0_go.out ? 4'd1;
    wrapper_early_reset_static_seq4_done.in = signal_reg.out ? 1'd1;
    add0.left = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out | fsm.out == 4'd1 & early_reset_static_seq1_go.out ? 4'd1;
    add0.right = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out | fsm.out == 4'd1 & early_reset_static_seq1_go.out ? idx0.out;
    b.clk = clk;
    b.addr0 = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out | fsm.out == 4'd0 & early_reset_static_seq1_go.out ? idx0.out;
    b.reset = reset;
    comb_reg.write_en = early_reset_in_range0_go.out | fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    comb_reg.clk = clk;
    comb_reg.reset = reset;
    comb_reg.in = early_reset_in_range0_go.out | fsm.out == 4'd7 & early_reset_static_seq1_go.out ? lt0.out;
    early_reset_static_par_thread0_done.in = ud.out;
    early_reset_static_seq4_go.in = wrapper_early_reset_static_seq4_go.out ? 1'd1;
    while_wrapper_early_reset_static_seq1_go.in = !while_wrapper_early_reset_static_seq1_done.out & fsm0.out == 3'd2 & tdcc_go.out ? 1'd1;
    read_b.write_en = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out | fsm.out == 4'd0 & early_reset_static_seq1_go.out ? 1'd1;
    read_b.clk = clk;
    read_b.reset = reset;
    read_b.in = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out | fsm.out == 4'd0 & early_reset_static_seq1_go.out ? b.read_data;
    idx0.write_en = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out | fsm.out == 4'd1 & early_reset_static_seq1_go.out ? 1'd1;
    idx0.clk = clk;
    idx0.reset = reset;
    idx0.in = fsm.out == 4'd1 & early_reset_static_par_thread0_go.out | fsm.out == 4'd1 & early_reset_static_seq1_go.out ? add0.out;
    early_reset_static_seq1_done.in = ud1.out;
    a.clk = clk;
    a.addr0 = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out | fsm.out == 4'd0 & early_reset_static_seq1_go.out ? idx0.out;
    a.reset = reset;
    out.write_en = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    out.clk = clk;
    out.addr0 = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? 1'd0;
    out.reset = reset;
    out.write_data = fsm.out == 4'd6 & early_reset_static_seq4_go.out ? mac.out;
    early_reset_static_seq1_go.in = while_wrapper_early_reset_static_seq1_go.out ? 1'd1;
    tdcc_go.in = go;
    fsm0.write_en = fsm0.out == 3'd4 | fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0_done.out & tdcc_go.out | fsm0.out == 3'd1 & wrapper_early_reset_in_range0_done.out & tdcc_go.out | fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1_done.out & tdcc_go.out | fsm0.out == 3'd3 & wrapper_early_reset_static_seq4_done.out & tdcc_go.out ? 1'd1;
    fsm0.clk = clk;
    fsm0.reset = reset;
    fsm0.in = fsm0.out == 3'd1 & wrapper_early_reset_in_range0_done.out & tdcc_go.out ? 3'd2;
    fsm0.in = fsm0.out == 3'd3 & wrapper_early_reset_static_seq4_done.out & tdcc_go.out ? 3'd4;
    fsm0.in = fsm0.out == 3'd0 & wrapper_early_reset_static_par_thread0_done.out & tdcc_go.out ? 3'd1;
    fsm0.in = fsm0.out == 3'd4 ? 3'd0;
    fsm0.in = fsm0.out == 3'd2 & while_wrapper_early_reset_static_seq1_done.out & tdcc_go.out ? 3'd3;
    adder0.left = early_reset_static_seq1_go.out ? fsm.out;
    adder0.right = early_reset_static_seq1_go.out ? 4'd1;
    wrapper_early_reset_static_par_thread0_go.in = !wrapper_early_reset_static_par_thread0_done.out & fsm0.out == 3'd0 & tdcc_go.out ? 1'd1;
    read_a.write_en = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out | fsm.out == 4'd0 & early_reset_static_seq1_go.out ? 1'd1;
    read_a.clk = clk;
    read_a.reset = reset;
    read_a.in = fsm.out == 4'd0 & early_reset_static_par_thread0_go.out | fsm.out == 4'd0 & early_reset_static_seq1_go.out ? a.read_data;
    signal_reg.write_en = signal_reg.out | fsm.out == 4'd6 & !signal_reg.out & wrapper_early_reset_static_par_thread0_go.out | !signal_reg.out & wrapper_early_reset_in_range0_go.out | fsm.out == 4'd6 & !signal_reg.out & wrapper_early_reset_static_seq4_go.out ? 1'd1;
    signal_reg.clk = clk;
    signal_reg.reset = reset;
    signal_reg.in = fsm.out == 4'd6 & !signal_reg.out & wrapper_early_reset_static_par_thread0_go.out | !signal_reg.out & wrapper_early_reset_in_range0_go.out | fsm.out == 4'd6 & !signal_reg.out & wrapper_early_reset_static_seq4_go.out ? 1'd1;
    signal_reg.in = signal_reg.out ? 1'd0;
    wrapper_early_reset_static_par_thread0_done.in = signal_reg.out ? 1'd1;
    early_reset_static_par_thread0_go.in = wrapper_early_reset_static_par_thread0_go.out ? 1'd1;
    early_reset_static_seq4_done.in = ud2.out;
    wrapper_early_reset_in_range0_go.in = !wrapper_early_reset_in_range0_done.out & fsm0.out == 3'd1 & tdcc_go.out ? 1'd1;
    tdcc_done.in = fsm0.out == 3'd4 ? 1'd1;
    mac.b = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out | fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? read_b.out;
    mac.data_valid = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out | fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? 1'd1;
    mac.clk = clk;
    mac.a = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out | fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out ? read_a.out;
    mac.go = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_par_thread0_go.out | fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out | fsm.out < 4'd6 & early_reset_static_seq4_go.out ? 1'd1;
    mac.reset = reset;
    mac.c = fsm.out >= 4'd1 & fsm.out < 4'd7 & early_reset_static_seq1_go.out | fsm.out < 4'd6 & early_reset_static_seq4_go.out ? mac.out;
    early_reset_in_range0_go.in = wrapper_early_reset_in_range0_go.out ? 1'd1;
    wrapper_early_reset_static_seq4_go.in = !wrapper_early_reset_static_seq4_done.out & fsm0.out == 3'd3 & tdcc_go.out ? 1'd1;
    lt0.left = early_reset_in_range0_go.out | fsm.out == 4'd7 & early_reset_static_seq1_go.out ? idx0.out;
    lt0.right = early_reset_in_range0_go.out | fsm.out == 4'd7 & early_reset_static_seq1_go.out ? 4'd10;
    early_reset_in_range0_done.in = ud0.out;
    while_wrapper_early_reset_static_seq1_done.in = !comb_reg.out & fsm.out == 4'd0 & 1'b1 ? 1'd1;
    a.write_en = 1'd0;
    b.write_en = 1'd0;
  }
  control {}
}
